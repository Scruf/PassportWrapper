{"version":3,"sources":["dbcs-codec.js"],"names":[],"mappings":"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","file":"dbcs-codec-compiled.js","sourcesContent":["\"use strict\"\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), \n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = new Buffer(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = new Buffer(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = new Buffer(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = new Buffer(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"]}