{"version":3,"sources":["urlencoded.js"],"names":[],"mappings":"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","file":"urlencoded-compiled.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:urlencoded')\nvar deprecate = require('depd')('body-parser')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = urlencoded\n\n/**\n * Cache of parser modules.\n */\n\nvar parsers = Object.create(null)\n\n/**\n * Create a middleware to parse urlencoded bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction urlencoded(options) {\n  var opts = options || {}\n\n  // notice because option default will flip in next major\n  if (opts.extended === undefined) {\n    deprecate('undefined extended: provide extended option')\n  }\n\n  var extended = opts.extended !== false\n  var inflate = opts.inflate !== false\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var type = opts.type || 'application/x-www-form-urlencoded'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate query parser\n  var queryparse = extended\n    ? extendedparser(opts)\n    : simpleparser(opts)\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse(body) {\n    return body.length\n      ? queryparse(body)\n      : {}\n  }\n\n  return function urlencodedParser(req, res, next) {\n    if (req._body) {\n      return debug('body already parsed'), next()\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      return debug('skip empty body'), next()\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      return debug('skip parsing'), next()\n    }\n\n    // assert charset\n    var charset = getCharset(req) || 'utf-8'\n    if (charset !== 'utf-8') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      debug: debug,\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the extended query parser.\n *\n * @param {object} options\n */\n\nfunction extendedparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('qs')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters')\n    }\n\n    var arrayLimit = Math.max(100, paramCount)\n\n    debug('parse extended urlencoding')\n    return parse(body, {\n      allowPrototypes: true,\n      arrayLimit: arrayLimit,\n      depth: Infinity,\n      parameterLimit: parameterLimit\n    })\n  }\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset(req) {\n  try {\n    return contentType.parse(req).parameters.charset.toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Count the number of parameters, stopping once limit reached\n *\n * @param {string} body\n * @param {number} limit\n * @api private\n */\n\nfunction parameterCount(body, limit) {\n  var count = 0\n  var index = 0\n\n  while ((index = body.indexOf('&', index)) !== -1) {\n    count++\n    index++\n\n    if (count === limit) {\n      return undefined\n    }\n  }\n\n  return count\n}\n\n/**\n * Get parser for module name dynamically.\n *\n * @param {string} name\n * @return {function}\n * @api private\n */\n\nfunction parser(name) {\n  var mod = parsers[name]\n\n  if (mod !== undefined) {\n    return mod.parse\n  }\n\n  // this uses a switch for static require analysis\n  switch (name) {\n    case 'qs':\n      mod = require('qs')\n      break\n    case 'querystring':\n      mod = require('querystring')\n      break\n  }\n\n  // store to prevent invoking require()\n  parsers[name] = mod\n\n  return mod.parse\n}\n\n/**\n * Get the simple query parser.\n *\n * @param {object} options\n */\n\nfunction simpleparser(options) {\n  var parameterLimit = options.parameterLimit !== undefined\n    ? options.parameterLimit\n    : 1000\n  var parse = parser('querystring')\n\n  if (isNaN(parameterLimit) || parameterLimit < 1) {\n    throw new TypeError('option parameterLimit must be a positive number')\n  }\n\n  if (isFinite(parameterLimit)) {\n    parameterLimit = parameterLimit | 0\n  }\n\n  return function queryparse(body) {\n    var paramCount = parameterCount(body, parameterLimit)\n\n    if (paramCount === undefined) {\n      debug('too many parameters')\n      throw createError(413, 'too many parameters')\n    }\n\n    debug('parse urlencoding')\n    return parse(body, undefined, undefined, {maxKeys: parameterLimit})\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}