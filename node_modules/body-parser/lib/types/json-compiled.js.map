{"version":3,"sources":["json.js"],"names":[],"mappings":"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","file":"json-compiled.js","sourcesContent":["/*!\n * body-parser\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar contentType = require('content-type')\nvar createError = require('http-errors')\nvar debug = require('debug')('body-parser:json')\nvar read = require('../read')\nvar typeis = require('type-is')\n\n/**\n * Module exports.\n */\n\nmodule.exports = json\n\n/**\n * RegExp to match the first non-space in a string.\n *\n * Allowed whitespace is defined in RFC 7159:\n *\n *    ws = *(\n *            %x20 /              ; Space\n *            %x09 /              ; Horizontal tab\n *            %x0A /              ; Line feed or New line\n *            %x0D )              ; Carriage return\n */\n\nvar firstcharRegExp = /^[\\x20\\x09\\x0a\\x0d]*(.)/\n\n/**\n * Create a middleware to parse JSON bodies.\n *\n * @param {object} [options]\n * @return {function}\n * @public\n */\n\nfunction json(options) {\n  var opts = options || {}\n\n  var limit = typeof opts.limit !== 'number'\n    ? bytes.parse(opts.limit || '100kb')\n    : opts.limit\n  var inflate = opts.inflate !== false\n  var reviver = opts.reviver\n  var strict = opts.strict !== false\n  var type = opts.type || 'application/json'\n  var verify = opts.verify || false\n\n  if (verify !== false && typeof verify !== 'function') {\n    throw new TypeError('option verify must be function')\n  }\n\n  // create the appropriate type checking function\n  var shouldParse = typeof type !== 'function'\n    ? typeChecker(type)\n    : type\n\n  function parse(body) {\n    if (body.length === 0) {\n      // special-case empty json body, as it's a common client-side mistake\n      // TODO: maybe make this configurable or part of \"strict\" option\n      return {}\n    }\n\n    if (strict) {\n      var first = firstchar(body)\n\n      if (first !== '{' && first !== '[') {\n        debug('strict violation')\n        throw new SyntaxError('Unexpected token ' + first)\n      }\n    }\n\n    debug('parse json')\n    return JSON.parse(body, reviver)\n  }\n\n  return function jsonParser(req, res, next) {\n    if (req._body) {\n      return debug('body already parsed'), next()\n    }\n\n    req.body = req.body || {}\n\n    // skip requests without bodies\n    if (!typeis.hasBody(req)) {\n      return debug('skip empty body'), next()\n    }\n\n    debug('content-type %j', req.headers['content-type'])\n\n    // determine if request should be parsed\n    if (!shouldParse(req)) {\n      return debug('skip parsing'), next()\n    }\n\n    // assert charset per RFC 7159 sec 8.1\n    var charset = getCharset(req) || 'utf-8'\n    if (charset.substr(0, 4) !== 'utf-') {\n      debug('invalid charset')\n      next(createError(415, 'unsupported charset \"' + charset.toUpperCase() + '\"', {\n        charset: charset\n      }))\n      return\n    }\n\n    // read\n    read(req, res, next, parse, debug, {\n      encoding: charset,\n      inflate: inflate,\n      limit: limit,\n      verify: verify\n    })\n  }\n}\n\n/**\n * Get the first non-whitespace character in a string.\n *\n * @param {string} str\n * @return {function}\n * @api public\n */\n\n\nfunction firstchar(str) {\n  var match = firstcharRegExp.exec(str)\n  return match ? match[1] : ''\n}\n\n/**\n * Get the charset of a request.\n *\n * @param {object} req\n * @api private\n */\n\nfunction getCharset(req) {\n  try {\n    return contentType.parse(req).parameters.charset.toLowerCase()\n  } catch (e) {\n    return undefined\n  }\n}\n\n/**\n * Get the simple type checker.\n *\n * @param {string} type\n * @return {function}\n */\n\nfunction typeChecker(type) {\n  return function checkType(req) {\n    return Boolean(typeis(req, type))\n  }\n}\n"]}