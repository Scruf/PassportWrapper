{"version":3,"sources":["node-iterator.js"],"names":[],"mappings":"AAAA;;AAEA,MAAM,gBAAgB,QAAQ,8BAAR,EAAwC,aAAxC;AACtB,MAAM,eAAe,QAAQ,UAAR,EAAoB,YAApB;AACrB,MAAM,WAAW,OAAO,uBAAP,CAAX;;AAEN,OAAO,OAAP,GAAiB,UAAU,IAAV,EAAgB;;;AAG/B,WAAS,oBAAT,CAA8B,QAA9B,EAAwC,IAAxC,EAA8C,UAA9C,EAA0D,MAA1D,EAAkE;AAChE,SAAK,MAAL,GAAc,IAAd,CADgE;AAEhE,SAAK,QAAL,GAAgB,QAAhB,CAFgE;AAGhE,SAAK,IAAL,GAAY,IAAZ,CAHgE;AAIhE,SAAK,aAAL,GAAqB,IAArB,CAJgE;AAKhE,SAAK,0BAAL,GAAkC,IAAlC,CALgE;AAMhE,SAAK,UAAL,GAAkB,UAAlB,CANgE;AAOhE,SAAK,MAAL,GAAc,MAAd,CAPgE;GAAlE;;AAUA,uBAAqB,SAArB,CAA+B,gBAA/B,GAAkD,YAAY;;AAE5D,QAAI,CAAC,KAAK,MAAL,EAAa;AAChB,YAAM,MAAM,4CACA,YADA,GACe,KAAK,QAAL,CAAc,uBAAd,GACf,0CAFA,GAGA,2DAHA,GAIA,0BAJA,CAAZ;;;AADgB,KAAlB;GAFgD,CAbnB;;AA2B/B,uBAAqB,SAArB,CAA+B,QAA/B,GAA0C,UAAU,IAAV,EAAgB;AACxD,QAAI,OAAO,KAAK,aAAL,CAD6C;AAExD,QAAI,aAAa,KAAK,0BAAL,CAFuC;;AAIxD,OAAG;AACD,UAAI,IAAJ,EAAU;AACR,YAAI,CAAC,UAAD,EAAa;AACf,iBAAO,cAAc,SAAd,CAAwB,IAAxB,EAA8B,EAAE,MAAM,KAAK,IAAL,EAAtC,CAAP,CADe;;AAGf,cAAI,CAAC,IAAD,EAAO;AACT,mBAAO,IAAP,CADS;WAAX;SAHF;;AAQA,qBAAa,KAAb,CATQ;OAAV,MAUO;;AACL,YAAI,UAAJ,EAAgB;AACd,iBAAO,cAAc,SAAd,CAAwB,IAAxB,EAA8B,EAAE,MAAM,KAAK,IAAL,EAAtC,CAAP,CADc;;AAGd,cAAI,CAAC,IAAD,EAAO;AACT,mBAAO,IAAP,CADS;WAAX;SAHF;;AAQA,qBAAa,IAAb,CATK;OAVP;KADF,QAuBO,KAAK,UAAL,CAAgB,IAAhB,MAA0B,KAAK,UAAL,CAAgB,aAAhB,EA3BuB;;AA6BxD,SAAK,0BAAL,GAAkC,UAAlC,CA7BwD;AA8BxD,SAAK,aAAL,GAAqB,IAArB,CA9BwD;AA+BxD,WAAO,IAAP,CA/BwD;GAAhB,CA3BX;;AA6D/B,uBAAqB,SAArB,CAA+B,UAA/B,GAA4C,UAAU,IAAV,EAAgB;AAC1D,UAAM,IAAI,KAAK,QAAL,GAAgB,CAAhB,CADgD;AAE1D,QAAI,EAAE,KAAK,UAAL,GAAmB,KAAK,CAAL,CAArB,EAA+B;AACjC,aAAO,KAAK,UAAL,CAAgB,WAAhB,CAD0B;KAAnC;;AAIA,QAAI,MAAM,KAAK,UAAL,CAAgB,aAAhB,CANgD;AAO1D,UAAM,SAAS,KAAK,MAAL,CAP2C;AAQ1D,QAAI,OAAO,MAAP,KAAkB,UAAlB,EAA8B;AAChC,YAAM,OAAO,IAAP,CAAN,CADgC;KAAlC,MAEO,IAAI,UAAU,OAAO,OAAO,UAAP,KAAsB,UAA7B,EAAyC;AAC5D,YAAM,OAAO,UAAP,CAAkB,IAAlB,CAAN,CAD4D;KAAvD;;AAIP,QAAI,QAAQ,IAAR,EAAc;AAChB,aAAO,KAAK,UAAL,CAAgB,aAAhB,CADS;KAAlB,MAEO,IAAI,QAAQ,KAAR,EAAe;AACxB,aAAO,KAAK,UAAL,CAAgB,aAAhB,CADiB;KAAnB;;AAIP,WAAO,GAAP,CApB0D;GAAhB,CA7Db;;AAoF/B,uBAAqB,SAArB,CAA+B,gBAA/B,GAAkD,UAAU,OAAV,EAAmB,SAAnB,EAA8B,kBAA9B,EAAkD;AAClG,QAAI,QAAQ,QAAR,CAAiB,KAAK,IAAL,CAArB,EAAiC;AAC/B,aAD+B;KAAjC;;;;AADkG,QAO9F,CAAC,QAAQ,QAAR,CAAiB,KAAK,aAAL,CAAlB,EAAuC;AACzC,aADyC;KAA3C;;AAIA,QAAI,KAAK,0BAAL,EAAiC;;;AAGnC,YAAM,cAAc,qBACA,mBAAmB,WAAnB,GACA,UAAU,UAAV;;;;AALe,UAS/B,WAAJ,EAAiB;AACf,aAAK,aAAL,GAAqB,WAArB,CADe;AAEf,eAFe;OAAjB;;;AATmC,YAe7B,OAAO,cAAc,SAAd,CAAwB,SAAxB,EAAmC,EAAE,cAAc,IAAd,EAArC,CAAP;;;;AAf6B,UAmB/B,KAAK,IAAL,CAAU,QAAV,CAAmB,IAAnB,CAAJ,EAA8B;AAC5B,aAAK,aAAL,GAAqB,IAArB,CAD4B;AAE5B,eAF4B;OAA9B;;;AAnBmC,UAyBnC,CAAK,0BAAL,GAAkC,KAAlC;;;AAzBmC,KAArC;;;;AAXkG,QA2ClG,CAAK,aAAL,GAAqB,qBACI,cAAc,uBAAd,CAAsC,kBAAtC,CADJ,GAEI,SAFJ,CA3C6E;GAAlD,CApFnB;;AAoI/B,OAAK,QAAL,CAAc,cAAd,CAA6B,IAA7B,CAAkC,CAAC,QAAD,EAAW,OAAX,EAAoB,SAApB,EAA+B,kBAA/B,KAAsD;AACtF,SAAK,IAAI,IAAI,CAAJ,EAAO,IAAI,SAAS,oBAAT,CAA8B,MAA9B,EAAsC,EAAE,CAAF,EAAK;AAC7D,YAAM,WAAW,SAAS,oBAAT,CAA8B,CAA9B,CAAX,CADuD;AAE7D,eAAS,gBAAT,CAA0B,OAA1B,EAAmC,SAAnC,EAA8C,kBAA9C,EAF6D;KAA/D;GADgC,CAAlC,CApI+B;;AA2I/B,OAAK,QAAL,CAAc,SAAd,CAAwB,kBAAxB,GAA6C,UAAU,IAAV,EAAgB,UAAhB,EAA4B,MAA5B,EAAoC;AAC/E,QAAI,CAAC,IAAD,EAAO;AACT,YAAM,IAAI,SAAJ,CAAc,sDAAd,CAAN,CADS;KAAX;;AAIA,QAAI,WAAW,SAAX,EAAsB;AACxB,eAAS,IAAT,CADwB;KAA1B;;AAIA,QAAI,WAAW,IAAX,IACA,OAAO,MAAP,KAAkB,UAAlB,IACA,OAAO,OAAO,UAAP,KAAsB,UAA7B,EAAyC;AAC3C,YAAM,IAAI,SAAJ,CAAc,yFAAd,CAAN,CAD2C;KAF7C;;AAMA,UAAM,WAAW,KAAK,cAAL,CAf8D;;AAiB/E,iBAAa,eAAe,SAAf,GACX,KAAK,UAAL,CAAgB,QAAhB,GACA,CAAC,aAAa,KAAK,UAAL,CAAgB,QAAhB,CAAd,KAA4C,CAA5C;;AAnB6E,UAqB/E,GAAS,UAAU,IAAV,CArBsE;;AAuB/E,UAAM,KAAK,OAAO,MAAP,CAAc,KAAK,YAAL,CAAkB,SAAlB,CAAnB,CAvByE;AAwB/E,UAAM,WAAW,IAAI,oBAAJ,CAAyB,QAAzB,EAAmC,IAAnC,EAAyC,UAAzC,EAAqD,MAArD,CAAX,CAxByE;AAyB/E,OAAG,QAAH,IAAe,QAAf,CAzB+E;;AA2B/E,aAAS,oBAAT,CAA8B,IAA9B,CAAmC,QAAnC,EA3B+E;AA4B/E,WAAO,SAAS,oBAAT,CAA8B,MAA9B,GAAuC,SAAS,uBAAT,EAAkC;AAC9E,YAAM,gBAAgB,SAAS,oBAAT,CAA8B,KAA9B,EAAhB,CADwE;AAE9E,oBAAc,MAAd,GAAuB,KAAvB,CAF8E;KAAhF;;AAKA,WAAO,EAAP,CAjC+E;GAApC,CA3Id;;AA+K/B,OAAK,YAAL,GAAoB,SAAS,YAAT,GAAwB;AAC1C,UAAM,IAAI,SAAJ,CAAc,qBAAd,CAAN,CAD0C;GAAxB,CA/KW;;AAmL/B,eAAa,KAAK,YAAL,CAAkB,SAAlB,EAA6B,MAA1C,EAAkD,YAAY;AAC5D,WAAO,KAAK,QAAL,EAAe,IAAf,CADqD;GAAZ,CAAlD,CAnL+B;;AAuL/B,eAAa,KAAK,YAAL,CAAkB,SAAlB,EAA6B,eAA1C,EAA2D,YAAY;AACrE,UAAM,WAAW,KAAK,QAAL,CAAX,CAD+D;AAErE,aAAS,gBAAT,GAFqE;AAGrE,WAAO,SAAS,aAAT,CAH8D;GAAZ,CAA3D,CAvL+B;;AA6L/B,eAAa,KAAK,YAAL,CAAkB,SAAlB,EAA6B,4BAA1C,EAAwE,YAAY;AAClF,UAAM,WAAW,KAAK,QAAL,CAAX,CAD4E;AAElF,aAAS,gBAAT,GAFkF;AAGlF,WAAO,SAAS,0BAAT,CAH2E;GAAZ,CAAxE,CA7L+B;;AAmM/B,eAAa,KAAK,YAAL,CAAkB,SAAlB,EAA6B,YAA1C,EAAwD,YAAY;AAClE,WAAO,KAAK,QAAL,EAAe,UAAf,CAD2D;GAAZ,CAAxD,CAnM+B;;AAuM/B,eAAa,KAAK,YAAL,CAAkB,SAAlB,EAA6B,QAA1C,EAAoD,YAAY;AAC9D,WAAO,KAAK,QAAL,EAAe,MAAf,CADuD;GAAZ,CAApD,CAvM+B;;AA2M/B,OAAK,YAAL,CAAkB,SAAlB,CAA4B,YAA5B,GAA2C,YAAY;AACrD,UAAM,WAAW,KAAK,QAAL,CAAX,CAD+C;AAErD,aAAS,gBAAT,GAFqD;AAGrD,WAAO,SAAS,QAAT,CAAkB,KAAlB,CAAP,CAHqD;GAAZ,CA3MZ;;AAiN/B,OAAK,YAAL,CAAkB,SAAlB,CAA4B,QAA5B,GAAuC,YAAY;AACjD,UAAM,WAAW,KAAK,QAAL,CAAX,CAD2C;AAEjD,aAAS,gBAAT,GAFiD;AAGjD,WAAO,SAAS,QAAT,CAAkB,IAAlB,CAAP,CAHiD;GAAZ,CAjNR;;AAuN/B,OAAK,YAAL,CAAkB,SAAlB,CAA4B,MAA5B,GAAqC,YAAY;;GAAZ,CAvNN;;AA2N/B,OAAK,YAAL,CAAkB,SAAlB,CAA4B,QAA5B,GAAuC,YAAY;AACjD,WAAO,uBAAP,CADiD;GAAZ,CA3NR;CAAhB","file":"node-iterator-compiled.js","sourcesContent":["\"use strict\";\n\nconst domSymbolTree = require(\"./helpers/internal-constants\").domSymbolTree;\nconst defineGetter = require(\"../utils\").defineGetter;\nconst INTERNAL = Symbol(\"NodeIterator internal\");\n\nmodule.exports = function (core) {\n  // https://dom.spec.whatwg.org/#interface-nodeiterator\n\n  function NodeIteratorInternal(document, root, whatToShow, filter) {\n    this.active = true;\n    this.document = document;\n    this.root = root;\n    this.referenceNode = root;\n    this.pointerBeforeReferenceNode = true;\n    this.whatToShow = whatToShow;\n    this.filter = filter;\n  }\n\n  NodeIteratorInternal.prototype.throwIfNotActive = function () {\n    // (only thrown for getters/methods that are affected by removing steps)\n    if (!this.active) {\n      throw Error(\"This NodeIterator is no longer active. \" +\n                  \"More than \" + this.document._activeNodeIteratorsMax +\n                  \" iterators are being used concurrently. \" +\n                  \"You can increase the 'concurrentNodeIterators' option to \" +\n                  \"make this error go away.\"\n      );\n      // Alternatively, you can pester Ecma to add support for weak references,\n      // the DOM standard assumes the implementor has control over object life cycles.\n    }\n  };\n\n  NodeIteratorInternal.prototype.traverse = function (next) {\n    let node = this.referenceNode;\n    let beforeNode = this.pointerBeforeReferenceNode;\n\n    do {\n      if (next) {\n        if (!beforeNode) {\n          node = domSymbolTree.following(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = false;\n      } else { // previous\n        if (beforeNode) {\n          node = domSymbolTree.preceding(node, { root: this.root });\n\n          if (!node) {\n            return null;\n          }\n        }\n\n        beforeNode = true;\n      }\n    }\n    while (this.filterNode(node) !== core.NodeFilter.FILTER_ACCEPT);\n\n    this.pointerBeforeReferenceNode = beforeNode;\n    this.referenceNode = node;\n    return node;\n  };\n\n  NodeIteratorInternal.prototype.filterNode = function (node) {\n    const n = node.nodeType - 1;\n    if (!(this.whatToShow & (1 << n))) {\n      return core.NodeFilter.FILTER_SKIP;\n    }\n\n    let ret = core.NodeFilter.FILTER_ACCEPT;\n    const filter = this.filter;\n    if (typeof filter === \"function\") {\n      ret = filter(node);\n    } else if (filter && typeof filter.acceptNode === \"function\") {\n      ret = filter.acceptNode(node);\n    }\n\n    if (ret === true) {\n      return core.NodeFilter.FILTER_ACCEPT;\n    } else if (ret === false) {\n      return core.NodeFilter.FILTER_REJECT;\n    }\n\n    return ret;\n  };\n\n  NodeIteratorInternal.prototype.runRemovingSteps = function (oldNode, oldParent, oldPreviousSibling) {\n    if (oldNode.contains(this.root)) {\n      return;\n    }\n\n    // If oldNode is not an inclusive ancestor of the referenceNode\n    // attribute value, terminate these steps.\n    if (!oldNode.contains(this.referenceNode)) {\n      return;\n    }\n\n    if (this.pointerBeforeReferenceNode) {\n      // Let nextSibling be oldPreviousSibling’s next sibling, if oldPreviousSibling is non-null,\n      // and oldParent’s first child otherwise.\n      const nextSibling = oldPreviousSibling ?\n                          oldPreviousSibling.nextSibling :\n                          oldParent.firstChild;\n\n      // If nextSibling is non-null, set the referenceNode attribute to nextSibling\n      // and terminate these steps.\n      if (nextSibling) {\n        this.referenceNode = nextSibling;\n        return;\n      }\n\n      // Let next be the first node following oldParent (excluding any children of oldParent).\n      const next = domSymbolTree.following(oldParent, { skipChildren: true });\n\n      // If root is an inclusive ancestor of next, set the referenceNode\n      // attribute to next and terminate these steps.\n      if (this.root.contains(next)) {\n        this.referenceNode = next;\n        return;\n      }\n\n      // Otherwise, set the pointerBeforeReferenceNode attribute to false.\n      this.pointerBeforeReferenceNode = false;\n\n      // Note: Steps are not terminated here.\n    }\n\n    // Set the referenceNode attribute to the last inclusive descendant in tree order of oldPreviousSibling,\n    // if oldPreviousSibling is non-null, and to oldParent otherwise.\n    this.referenceNode = oldPreviousSibling ?\n                             domSymbolTree.lastInclusiveDescendant(oldPreviousSibling) :\n                             oldParent;\n  };\n\n  core.Document._removingSteps.push((document, oldNode, oldParent, oldPreviousSibling) => {\n    for (let i = 0; i < document._activeNodeIterators.length; ++i) {\n      const internal = document._activeNodeIterators[i];\n      internal.runRemovingSteps(oldNode, oldParent, oldPreviousSibling);\n    }\n  });\n\n  core.Document.prototype.createNodeIterator = function (root, whatToShow, filter) {\n    if (!root) {\n      throw new TypeError(\"Not enough arguments to Document.createNodeIterator.\");\n    }\n\n    if (filter === undefined) {\n      filter = null;\n    }\n\n    if (filter !== null &&\n        typeof filter !== \"function\" &&\n        typeof filter.acceptNode !== \"function\") {\n      throw new TypeError(\"Argument 3 of Document.createNodeIterator should be a function or implement NodeFilter.\");\n    }\n\n    const document = root._ownerDocument;\n\n    whatToShow = whatToShow === undefined ?\n      core.NodeFilter.SHOW_ALL :\n      (whatToShow & core.NodeFilter.SHOW_ALL) >>> 0; // >>> makes sure the result is unsigned\n\n    filter = filter || null;\n\n    const it = Object.create(core.NodeIterator.prototype);\n    const internal = new NodeIteratorInternal(document, root, whatToShow, filter);\n    it[INTERNAL] = internal;\n\n    document._activeNodeIterators.push(internal);\n    while (document._activeNodeIterators.length > document._activeNodeIteratorsMax) {\n      const internalOther = document._activeNodeIterators.shift();\n      internalOther.active = false;\n    }\n\n    return it;\n  };\n\n  core.NodeIterator = function NodeIterator() {\n    throw new TypeError(\"Illegal constructor\");\n  };\n\n  defineGetter(core.NodeIterator.prototype, \"root\", function () {\n    return this[INTERNAL].root;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"referenceNode\", function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return internal.referenceNode;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"pointerBeforeReferenceNode\", function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return internal.pointerBeforeReferenceNode;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"whatToShow\", function () {\n    return this[INTERNAL].whatToShow;\n  });\n\n  defineGetter(core.NodeIterator.prototype, \"filter\", function () {\n    return this[INTERNAL].filter;\n  });\n\n  core.NodeIterator.prototype.previousNode = function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return internal.traverse(false);\n  };\n\n  core.NodeIterator.prototype.nextNode = function () {\n    const internal = this[INTERNAL];\n    internal.throwIfNotActive();\n    return internal.traverse(true);\n  };\n\n  core.NodeIterator.prototype.detach = function () {\n    // noop\n  };\n\n  core.NodeIterator.prototype.toString = function () {\n    return \"[object NodeIterator]\";\n  };\n};\n"]}