{"version":3,"sources":["index.js"],"names":[],"mappings":"AAAA,IAAI,SAAS,QAAQ,QAAR,CAAT;AACJ,IAAI,aAAa,QAAQ,MAAR,EAAgB,UAAhB;AACjB,IAAI,YAAY,QAAQ,aAAR,EAAuB,SAAvB;AAChB,QAAQ,QAAR,GAAmB,QAAQ,cAAR,CAAnB;;;AAGA,SAAS,QAAT,CAAkB,GAAlB,EAAsB,GAAtB,EACA;AACC,SAAO,GAAC,CAAI,MAAJ,IAAc,GAAd,GAAqB,GAAtB,GAA4B,SAAS,MAAI,GAAJ,EAAQ,GAAjB,CAA5B,CADR;CADA;;AAKA,QAAQ,KAAR,GAAgB,UAAS,KAAT,EAAgB,GAAhB,EAAqB,QAArB,EAChB;AACE,MAAI,IAAJ,CADF;AAEC,MAAI,IAAI,OAAJ,CAFL;AAGC,MAAI,IAAI,EAAE,IAAF,EAAJ,CAHL;AAIE,MAAI,QAAQ,KAAK,KAAL,CAAW,EAAE,SAAF,KAAc,CAAd,CAAnB,CAJN;;AAME,MAAG,GAAH,EACA;AACE,QAAG,QAAH,EACA;AACE,UAAI,QAAQ,EAAE,QAAF,EAAR;;;;;;AADN,UAOE,CAAK,CAAL,GAAS,MAAM,cAAN,CAAqB,IAAI,QAAJ,CAAa,KAAb,CAArB,CAAT,CAPF;KADA,MASK;AACH,UAAG,IAAI,MAAJ,IAAc,KAAd,EAAqB,OAAO,KAAP,CAAxB;AACA,aAAO,IAAI,UAAJ,CAAe,IAAI,QAAJ,CAAa,KAAb,CAAf,EAAoC,EAApC,CAAP,CAFG;KATL;GAFF,MAeK;AACH,QAAI,KAAK,EAAE,QAAF,CAAW,WAAW,GAAX,CAAhB,CADD;AAEH,QAAI,IAAI,IAAI,UAAJ,CAAe,OAAO,WAAP,CAAmB,EAAE,SAAF,EAAnB,CAAf,CAAJ,CAFD;AAGH,WAAO,EAAE,GAAF,CAAM,EAAN,EAAU,GAAV,CAAc,WAAW,GAAX,CAArB,CAHG;AAIH,SAAK,CAAL,GAAS,EAAE,IAAF,GAAS,QAAT,CAAkB,IAAlB,CAAT,CAJG;GAfL;AAqBA,MAAG,KAAK,CAAL,EACH;;;AAGE,SAAK,SAAL,GAAiB,IAAI,MAAJ,CAAW,EAAE,QAAF,GAAa,wBAAb,CAAsC,KAAK,CAAL,CAAjD,EAAyD,KAAzD,CAAjB,CAHF;GADA;AAMA,MAAG,IAAH,EACA;AACE,SAAK,UAAL,GAAkB,IAAI,MAAJ,CAAW,SAAS,KAAK,QAAL,CAAc,EAAd,CAAT,EAA2B,QAAM,CAAN,CAAtC,EAA+C,KAA/C,CAAlB,CADF;AAEE,SAAK,kBAAL,GAA0B,UAAS,GAAT,EAC1B;AACE,UAAG,CAAC,GAAD,IAAQ,CAAC,IAAI,CAAJ,EAAO,OAAO,KAAP,CAAnB;AACA,UAAI,IAAI,IAAI,CAAJ,CAAM,QAAN,CAAe,IAAf,CAAJ,CAFN;AAGE,aAAO,IAAI,MAAJ,CAAW,SAAS,EAAE,IAAF,GAAS,YAAT,GAAwB,QAAxB,CAAiC,EAAjC,CAAT,EAA8C,QAAM,CAAN,CAAzD,EAAkE,KAAlE,CAAP,CAHF;KAD0B,CAF5B;GADA;CAlCc","file":"index-compiled.js","sourcesContent":["var crypto = require(\"crypto\");\nvar BigInteger = require(\"jsbn\").BigInteger;\nvar ECPointFp = require(\"./lib/ec.js\").ECPointFp;\nexports.ECCurves = require(\"./lib/sec.js\");\n\n// zero prepad\nfunction unstupid(hex,len)\n{\n\treturn (hex.length >= len) ? hex : unstupid(\"0\"+hex,len);\n}\n\nexports.ECKey = function(curve, key, isPublic)\n{\n  var priv;\n\tvar c = curve();\n\tvar n = c.getN();\n  var bytes = Math.floor(n.bitLength()/8);\n\n  if(key)\n  {\n    if(isPublic)\n    {\n      var curve = c.getCurve();\n//      var x = key.slice(1,bytes+1); // skip the 04 for uncompressed format\n//      var y = key.slice(bytes+1);\n//      this.P = new ECPointFp(curve,\n//        curve.fromBigInteger(new BigInteger(x.toString(\"hex\"), 16)),\n//        curve.fromBigInteger(new BigInteger(y.toString(\"hex\"), 16)));      \n      this.P = curve.decodePointHex(key.toString(\"hex\"));\n    }else{\n      if(key.length != bytes) return false;\n      priv = new BigInteger(key.toString(\"hex\"), 16);      \n    }\n  }else{\n    var n1 = n.subtract(BigInteger.ONE);\n    var r = new BigInteger(crypto.randomBytes(n.bitLength()));\n    priv = r.mod(n1).add(BigInteger.ONE);\n    this.P = c.getG().multiply(priv);\n  }\n  if(this.P)\n  {\n//  var pubhex = unstupid(this.P.getX().toBigInteger().toString(16),bytes*2)+unstupid(this.P.getY().toBigInteger().toString(16),bytes*2);\n//  this.PublicKey = new Buffer(\"04\"+pubhex,\"hex\");\n    this.PublicKey = new Buffer(c.getCurve().encodeCompressedPointHex(this.P),\"hex\");\n  }\n  if(priv)\n  {\n    this.PrivateKey = new Buffer(unstupid(priv.toString(16),bytes*2),\"hex\");\n    this.deriveSharedSecret = function(key)\n    {\n      if(!key || !key.P) return false;\n      var S = key.P.multiply(priv);\n      return new Buffer(unstupid(S.getX().toBigInteger().toString(16),bytes*2),\"hex\");\n   }     \n  }\n}\n\n"]}