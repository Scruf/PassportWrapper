{"version":3,"sources":["location_info_mixin.js"],"names":[],"mappings":"AAAA;;AAEA,QAAQ,MAAR,GAAiB,UAAU,SAAV,EAAqB;;AAElC,QAAI,iBAAiB,OAAO,cAAP,CAAsB,SAAtB,CAAjB,CAF8B;;AAIlC,cAAU,aAAV,GAA0B,CAAC,CAAD;;;AAJQ,aAOlC,CAAU,mBAAV,GAAgC,UAAU,KAAV,EAAiB;AAC7C,cAAM,QAAN,GAAiB;AACb,mBAAO,KAAK,aAAL;AACP,iBAAK,CAAC,CAAD;SAFT,CAD6C;KAAjB;;;AAPE,aAelC,CAAU,oBAAV,GAAiC,UAAU,cAAV,EAA0B;AACvD,uBAAe,oBAAf,CAAoC,IAApC,CAAyC,IAAzC,EAA+C,cAA/C,EADuD;AAEvD,aAAK,mBAAL,CAAyB,KAAK,YAAL,CAAzB,CAFuD;KAA1B,CAfC;;AAoBlC,cAAU,kBAAV,GAA+B,UAAU,cAAV,EAA0B;AACrD,uBAAe,kBAAf,CAAkC,IAAlC,CAAuC,IAAvC,EAA6C,cAA7C,EADqD;AAErD,aAAK,mBAAL,CAAyB,KAAK,YAAL,CAAzB,CAFqD;KAA1B,CApBG;;AAyBlC,cAAU,mBAAV,GAAgC,YAAY;AACxC,uBAAe,mBAAf,CAAmC,IAAnC,CAAwC,IAAxC,EADwC;AAExC,aAAK,mBAAL,CAAyB,KAAK,YAAL,CAAzB,CAFwC;KAAZ,CAzBE;;AA8BlC,cAAU,mBAAV,GAAgC,UAAU,kBAAV,EAA8B;AAC1D,uBAAe,mBAAf,CAAmC,IAAnC,CAAwC,IAAxC,EAA8C,kBAA9C,EAD0D;AAE1D,aAAK,mBAAL,CAAyB,KAAK,YAAL,CAAzB,CAF0D;KAA9B,CA9BE;;AAmClC,cAAU,qBAAV,GAAkC,UAAU,IAAV,EAAgB,EAAhB,EAAoB;AAClD,uBAAe,qBAAf,CAAqC,IAArC,CAA0C,IAA1C,EAAgD,IAAhD,EAAsD,EAAtD,EADkD;AAElD,aAAK,mBAAL,CAAyB,KAAK,qBAAL,CAAzB,CAFkD;KAApB;;;AAnCA,aAyClC,CAAU,iBAAV,GAA8B,YAAY;;;AAGtC,YAAI,KAAK,qBAAL,EACA,KAAK,qBAAL,CAA2B,QAA3B,CAAoC,GAApC,GAA0C,KAAK,YAAL,CAAkB,QAAlB,CAA2B,KAA3B,CAD9C;;AAGA,aAAK,YAAL,CAAkB,QAAlB,CAA2B,GAA3B,GAAiC,KAAK,YAAL,CAAkB,GAAlB,GAAwB,CAAxB,CANK;AAOtC,uBAAe,iBAAf,CAAiC,IAAjC,CAAsC,IAAtC,EAPsC;KAAZ,CAzCI;;AAmDlC,cAAU,0BAAV,GAAuC,YAAY;;;AAG/C,YAAI,KAAK,qBAAL,IAA8B,KAAK,qBAAL,CAA2B,QAA3B,CAAoC,GAApC,KAA4C,CAAC,CAAD,EAAI;;;;AAI9E,iBAAK,qBAAL,CAA2B,QAA3B,CAAoC,GAApC,GAA0C,KAAK,YAAL,CAAkB,GAAlB,CAJoC;SAAlF;;AAOA,uBAAe,0BAAf,CAA0C,IAA1C,CAA+C,IAA/C,EAV+C;KAAZ;;;AAnDL,UAiElC,CAAO,IAAP,CAAY,eAAe,IAAf,CAAZ,CAEK,GAFL,CAES,UAAU,QAAV,EAAoB;AACrB,eAAO,eAAe,IAAf,CAAoB,QAApB,CAAP,CADqB;KAApB,CAFT,CAMK,OANL,CAMa,UAAU,KAAV,EAAiB;AACtB,kBAAU,KAAV,IAAmB,UAAU,EAAV,EAAc;AAC7B,iBAAK,aAAL,GAAqB,KAAK,YAAL,CAAkB,GAAlB,CADQ;AAE7B,2BAAe,KAAf,EAAsB,IAAtB,CAA2B,IAA3B,EAAiC,EAAjC,EAF6B;SAAd,CADG;KAAjB,CANb,CAjEkC;CAArB","file":"location_info_mixin-compiled.js","sourcesContent":["'use strict';\r\n\r\nexports.assign = function (tokenizer) {\r\n    //NOTE: obtain Tokenizer proto this way to avoid module circular references\r\n    var tokenizerProto = Object.getPrototypeOf(tokenizer);\r\n\r\n    tokenizer.tokenStartLoc = -1;\r\n\r\n    //NOTE: add location info builder method\r\n    tokenizer._attachLocationInfo = function (token) {\r\n        token.location = {\r\n            start: this.tokenStartLoc,\r\n            end: -1\r\n        };\r\n    };\r\n\r\n    //NOTE: patch token creation methods and attach location objects\r\n    tokenizer._createStartTagToken = function (tagNameFirstCh) {\r\n        tokenizerProto._createStartTagToken.call(this, tagNameFirstCh);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createEndTagToken = function (tagNameFirstCh) {\r\n        tokenizerProto._createEndTagToken.call(this, tagNameFirstCh);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createCommentToken = function () {\r\n        tokenizerProto._createCommentToken.call(this);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createDoctypeToken = function (doctypeNameFirstCh) {\r\n        tokenizerProto._createDoctypeToken.call(this, doctypeNameFirstCh);\r\n        this._attachLocationInfo(this.currentToken);\r\n    };\r\n\r\n    tokenizer._createCharacterToken = function (type, ch) {\r\n        tokenizerProto._createCharacterToken.call(this, type, ch);\r\n        this._attachLocationInfo(this.currentCharacterToken);\r\n    };\r\n\r\n    //NOTE: patch token emission methods to determine end location\r\n    tokenizer._emitCurrentToken = function () {\r\n        //NOTE: if we have pending character token make it's end location equal to the\r\n        //current token's start location.\r\n        if (this.currentCharacterToken)\r\n            this.currentCharacterToken.location.end = this.currentToken.location.start;\r\n\r\n        this.currentToken.location.end = this.preprocessor.pos + 1;\r\n        tokenizerProto._emitCurrentToken.call(this);\r\n    };\r\n\r\n    tokenizer._emitCurrentCharacterToken = function () {\r\n        //NOTE: if we have character token and it's location wasn't set in the _emitCurrentToken(),\r\n        //then set it's location at the current preprocessor position\r\n        if (this.currentCharacterToken && this.currentCharacterToken.location.end === -1) {\r\n            //NOTE: we don't need to increment preprocessor position, since character token\r\n            //emission is always forced by the start of the next character token here.\r\n            //So, we already have advanced position.\r\n            this.currentCharacterToken.location.end = this.preprocessor.pos;\r\n        }\r\n\r\n        tokenizerProto._emitCurrentCharacterToken.call(this);\r\n    };\r\n\r\n    //NOTE: patch initial states for each mode to obtain token start position\r\n    Object.keys(tokenizerProto.MODE)\r\n\r\n        .map(function (modeName) {\r\n            return tokenizerProto.MODE[modeName];\r\n        })\r\n\r\n        .forEach(function (state) {\r\n            tokenizer[state] = function (cp) {\r\n                this.tokenStartLoc = this.preprocessor.pos;\r\n                tokenizerProto[state].call(this, cp);\r\n            };\r\n        });\r\n};\r\n"]}