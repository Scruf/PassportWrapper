{"version":3,"sources":["tokentype.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAuBA,OAAO,MAAM,SAAN,CAAgB;AACrB,cAAY,KAAZ,EAAmB,OAAO,EAAP,EAAW;AAC5B,SAAK,KAAL,GAAa,KAAb,CAD4B;AAE5B,SAAK,OAAL,GAAe,KAAK,OAAL,CAFa;AAG5B,SAAK,UAAL,GAAkB,CAAC,CAAC,KAAK,UAAL,CAHQ;AAI5B,SAAK,UAAL,GAAkB,CAAC,CAAC,KAAK,UAAL,CAJQ;AAK5B,SAAK,MAAL,GAAc,CAAC,CAAC,KAAK,MAAL,CALY;AAM5B,SAAK,QAAL,GAAgB,CAAC,CAAC,KAAK,QAAL,CANU;AAO5B,SAAK,MAAL,GAAc,CAAC,CAAC,KAAK,MAAL,CAPY;AAQ5B,SAAK,OAAL,GAAe,CAAC,CAAC,KAAK,OAAL,CARW;AAS5B,SAAK,KAAL,GAAa,KAAK,KAAL,IAAc,IAAd,CATe;AAU5B,SAAK,aAAL,GAAqB,IAArB,CAV4B;GAA9B;CADK;;AAeP,SAAS,KAAT,CAAe,IAAf,EAAqB,IAArB,EAA2B;AACzB,SAAO,IAAI,SAAJ,CAAc,IAAd,EAAoB,EAAC,YAAY,IAAZ,EAAkB,OAAO,IAAP,EAAvC,CAAP,CADyB;CAA3B;AAGA,MAAM,aAAa,EAAC,YAAY,IAAZ,EAAd;MAAiC,aAAa,EAAC,YAAY,IAAZ,EAAd;;AAEvC,OAAO,MAAM,QAAQ;AACnB,OAAK,IAAI,SAAJ,CAAc,KAAd,EAAqB,UAArB,CAAL;AACA,UAAQ,IAAI,SAAJ,CAAc,QAAd,EAAwB,UAAxB,CAAR;AACA,UAAQ,IAAI,SAAJ,CAAc,QAAd,EAAwB,UAAxB,CAAR;AACA,QAAM,IAAI,SAAJ,CAAc,MAAd,EAAsB,UAAtB,CAAN;AACA,OAAK,IAAI,SAAJ,CAAc,KAAd,CAAL;;;AAGA,YAAU,IAAI,SAAJ,CAAc,GAAd,EAAmB,EAAC,YAAY,IAAZ,EAAkB,YAAY,IAAZ,EAAtC,CAAV;AACA,YAAU,IAAI,SAAJ,CAAc,GAAd,CAAV;AACA,UAAQ,IAAI,SAAJ,CAAc,GAAd,EAAmB,EAAC,YAAY,IAAZ,EAAkB,YAAY,IAAZ,EAAtC,CAAR;AACA,UAAQ,IAAI,SAAJ,CAAc,GAAd,CAAR;AACA,UAAQ,IAAI,SAAJ,CAAc,GAAd,EAAmB,EAAC,YAAY,IAAZ,EAAkB,YAAY,IAAZ,EAAtC,CAAR;AACA,UAAQ,IAAI,SAAJ,CAAc,GAAd,CAAR;AACA,SAAO,IAAI,SAAJ,CAAc,GAAd,EAAmB,UAAnB,CAAP;AACA,QAAM,IAAI,SAAJ,CAAc,GAAd,EAAmB,UAAnB,CAAN;AACA,SAAO,IAAI,SAAJ,CAAc,GAAd,EAAmB,UAAnB,CAAP;AACA,OAAK,IAAI,SAAJ,CAAc,GAAd,CAAL;AACA,YAAU,IAAI,SAAJ,CAAc,GAAd,EAAmB,UAAnB,CAAV;AACA,SAAO,IAAI,SAAJ,CAAc,IAAd,EAAoB,UAApB,CAAP;AACA,YAAU,IAAI,SAAJ,CAAc,UAAd,CAAV;AACA,YAAU,IAAI,SAAJ,CAAc,KAAd,EAAqB,UAArB,CAAV;AACA,aAAW,IAAI,SAAJ,CAAc,GAAd,EAAmB,UAAnB,CAAX;AACA,gBAAc,IAAI,SAAJ,CAAc,IAAd,EAAoB,EAAC,YAAY,IAAZ,EAAkB,YAAY,IAAZ,EAAvC,CAAd;;;;;;;;;;;;;;;;AAgBA,MAAI,IAAI,SAAJ,CAAc,GAAd,EAAmB,EAAC,YAAY,IAAZ,EAAkB,UAAU,IAAV,EAAtC,CAAJ;AACA,UAAQ,IAAI,SAAJ,CAAc,IAAd,EAAoB,EAAC,YAAY,IAAZ,EAAkB,UAAU,IAAV,EAAvC,CAAR;AACA,UAAQ,IAAI,SAAJ,CAAc,OAAd,EAAuB,EAAC,QAAQ,IAAR,EAAc,SAAS,IAAT,EAAe,YAAY,IAAZ,EAArD,CAAR;AACA,UAAQ,IAAI,SAAJ,CAAc,QAAd,EAAwB,EAAC,YAAY,IAAZ,EAAkB,QAAQ,IAAR,EAAc,YAAY,IAAZ,EAAzD,CAAR;AACA,aAAW,MAAM,IAAN,EAAY,CAAZ,CAAX;AACA,cAAY,MAAM,IAAN,EAAY,CAAZ,CAAZ;AACA,aAAW,MAAM,GAAN,EAAW,CAAX,CAAX;AACA,cAAY,MAAM,GAAN,EAAW,CAAX,CAAZ;AACA,cAAY,MAAM,GAAN,EAAW,CAAX,CAAZ;AACA,YAAU,MAAM,OAAN,EAAe,CAAf,CAAV;AACA,cAAY,MAAM,KAAN,EAAa,CAAb,CAAZ;AACA,YAAU,MAAM,OAAN,EAAe,CAAf,CAAV;AACA,WAAS,IAAI,SAAJ,CAAc,KAAd,EAAqB,EAAC,YAAY,IAAZ,EAAkB,OAAO,CAAP,EAAU,QAAQ,IAAR,EAAc,YAAY,IAAZ,EAAhE,CAAT;AACA,UAAQ,MAAM,GAAN,EAAW,EAAX,CAAR;AACA,QAAM,MAAM,GAAN,EAAW,EAAX,CAAN;AACA,SAAO,MAAM,GAAN,EAAW,EAAX,CAAP;CAtDW,CAAb;;;;AA2DA,OAAO,MAAM,WAAW,EAAX,CAAb;;;AAGA,SAAS,EAAT,CAAY,IAAZ,EAAkB,UAAU,EAAV,EAAc;AAC9B,UAAQ,OAAR,GAAkB,IAAlB,CAD8B;AAE9B,WAAS,IAAT,IAAiB,MAAM,MAAM,IAAN,CAAN,GAAoB,IAAI,SAAJ,CAAc,IAAd,EAAoB,OAApB,CAApB,CAFa;CAAhC;;AAKA,GAAG,OAAH;AACA,GAAG,MAAH,EAAW,UAAX;AACA,GAAG,OAAH;AACA,GAAG,UAAH;AACA,GAAG,UAAH;AACA,GAAG,SAAH,EAAc,UAAd;AACA,GAAG,IAAH,EAAS,EAAC,QAAQ,IAAR,EAAc,YAAY,IAAZ,EAAxB;AACA,GAAG,MAAH,EAAW,UAAX;AACA,GAAG,SAAH;AACA,GAAG,KAAH,EAAU,EAAC,QAAQ,IAAR,EAAX;AACA,GAAG,UAAH,EAAe,UAAf;AACA,GAAG,IAAH;AACA,GAAG,QAAH,EAAa,UAAb;AACA,GAAG,QAAH;AACA,GAAG,OAAH,EAAY,UAAZ;AACA,GAAG,KAAH;AACA,GAAG,KAAH;AACA,GAAG,KAAH;AACA,GAAG,OAAH;AACA,GAAG,OAAH,EAAY,EAAC,QAAQ,IAAR,EAAb;AACA,GAAG,MAAH;AACA,GAAG,KAAH,EAAU,EAAC,YAAY,IAAZ,EAAkB,YAAY,IAAZ,EAA7B;AACA,GAAG,MAAH,EAAW,UAAX;AACA,GAAG,OAAH,EAAY,UAAZ;AACA,GAAG,OAAH;AACA,GAAG,SAAH,EAAc,UAAd;AACA,GAAG,QAAH;AACA,GAAG,QAAH;AACA,GAAG,OAAH,EAAY,EAAC,YAAY,IAAZ,EAAkB,YAAY,IAAZ,EAA/B;AACA,GAAG,MAAH,EAAW,UAAX;AACA,GAAG,MAAH,EAAW,UAAX;AACA,GAAG,OAAH,EAAY,UAAZ;AACA,GAAG,IAAH,EAAS,EAAC,YAAY,IAAZ,EAAkB,OAAO,CAAP,EAA5B;AACA,GAAG,YAAH,EAAiB,EAAC,YAAY,IAAZ,EAAkB,OAAO,CAAP,EAApC;AACA,GAAG,QAAH,EAAa,EAAC,YAAY,IAAZ,EAAkB,QAAQ,IAAR,EAAc,YAAY,IAAZ,EAA9C;AACA,GAAG,MAAH,EAAW,EAAC,YAAY,IAAZ,EAAkB,QAAQ,IAAR,EAAc,YAAY,IAAZ,EAA5C;AACA,GAAG,QAAH,EAAa,EAAC,YAAY,IAAZ,EAAkB,QAAQ,IAAR,EAAc,YAAY,IAAZ,EAA9C","file":"tokentype-compiled.js","sourcesContent":["// ## Token types\n\n// The assignment of fine-grained, information-carrying type objects\n// allows the tokenizer to store the information it has about a\n// token in a way that is very cheap for the parser to look up.\n\n// All token type variables start with an underscore, to make them\n// easy to recognize.\n\n// The `beforeExpr` property is used to disambiguate between regular\n// expressions and divisions. It is set on all token types that can\n// be followed by an expression (thus, a slash after them would be a\n// regular expression).\n//\n// The `startsExpr` property is used to check if the token ends a\n// `yield` expression. It is set on all token types that either can\n// directly start an expression (like a quotation mark) or can\n// continue an expression (like the body of a string).\n//\n// `isLoop` marks a keyword as starting a loop, which is important\n// to know when parsing a label, in order to allow or disallow\n// continue jumps to that label.\n\nexport class TokenType {\n  constructor(label, conf = {}) {\n    this.label = label\n    this.keyword = conf.keyword\n    this.beforeExpr = !!conf.beforeExpr\n    this.startsExpr = !!conf.startsExpr\n    this.isLoop = !!conf.isLoop\n    this.isAssign = !!conf.isAssign\n    this.prefix = !!conf.prefix\n    this.postfix = !!conf.postfix\n    this.binop = conf.binop || null\n    this.updateContext = null\n  }\n}\n\nfunction binop(name, prec) {\n  return new TokenType(name, {beforeExpr: true, binop: prec})\n}\nconst beforeExpr = {beforeExpr: true}, startsExpr = {startsExpr: true}\n\nexport const types = {\n  num: new TokenType(\"num\", startsExpr),\n  regexp: new TokenType(\"regexp\", startsExpr),\n  string: new TokenType(\"string\", startsExpr),\n  name: new TokenType(\"name\", startsExpr),\n  eof: new TokenType(\"eof\"),\n\n  // Punctuation token types.\n  bracketL: new TokenType(\"[\", {beforeExpr: true, startsExpr: true}),\n  bracketR: new TokenType(\"]\"),\n  braceL: new TokenType(\"{\", {beforeExpr: true, startsExpr: true}),\n  braceR: new TokenType(\"}\"),\n  parenL: new TokenType(\"(\", {beforeExpr: true, startsExpr: true}),\n  parenR: new TokenType(\")\"),\n  comma: new TokenType(\",\", beforeExpr),\n  semi: new TokenType(\";\", beforeExpr),\n  colon: new TokenType(\":\", beforeExpr),\n  dot: new TokenType(\".\"),\n  question: new TokenType(\"?\", beforeExpr),\n  arrow: new TokenType(\"=>\", beforeExpr),\n  template: new TokenType(\"template\"),\n  ellipsis: new TokenType(\"...\", beforeExpr),\n  backQuote: new TokenType(\"`\", startsExpr),\n  dollarBraceL: new TokenType(\"${\", {beforeExpr: true, startsExpr: true}),\n\n  // Operators. These carry several kinds of properties to help the\n  // parser use them properly (the presence of these properties is\n  // what categorizes them as operators).\n  //\n  // `binop`, when present, specifies that this operator is a binary\n  // operator, and will refer to its precedence.\n  //\n  // `prefix` and `postfix` mark the operator as a prefix or postfix\n  // unary operator.\n  //\n  // `isAssign` marks all of `=`, `+=`, `-=` etcetera, which act as\n  // binary operators with a very low precedence, that should result\n  // in AssignmentExpression nodes.\n\n  eq: new TokenType(\"=\", {beforeExpr: true, isAssign: true}),\n  assign: new TokenType(\"_=\", {beforeExpr: true, isAssign: true}),\n  incDec: new TokenType(\"++/--\", {prefix: true, postfix: true, startsExpr: true}),\n  prefix: new TokenType(\"prefix\", {beforeExpr: true, prefix: true, startsExpr: true}),\n  logicalOR: binop(\"||\", 1),\n  logicalAND: binop(\"&&\", 2),\n  bitwiseOR: binop(\"|\", 3),\n  bitwiseXOR: binop(\"^\", 4),\n  bitwiseAND: binop(\"&\", 5),\n  equality: binop(\"==/!=\", 6),\n  relational: binop(\"</>\", 7),\n  bitShift: binop(\"<</>>\", 8),\n  plusMin: new TokenType(\"+/-\", {beforeExpr: true, binop: 9, prefix: true, startsExpr: true}),\n  modulo: binop(\"%\", 10),\n  star: binop(\"*\", 10),\n  slash: binop(\"/\", 10)\n}\n\n// Map keyword names to token types.\n\nexport const keywords = {}\n\n// Succinct definitions of keyword token types\nfunction kw(name, options = {}) {\n  options.keyword = name\n  keywords[name] = types[\"_\" + name] = new TokenType(name, options)\n}\n\nkw(\"break\")\nkw(\"case\", beforeExpr)\nkw(\"catch\")\nkw(\"continue\")\nkw(\"debugger\")\nkw(\"default\", beforeExpr)\nkw(\"do\", {isLoop: true, beforeExpr: true})\nkw(\"else\", beforeExpr)\nkw(\"finally\")\nkw(\"for\", {isLoop: true})\nkw(\"function\", startsExpr)\nkw(\"if\")\nkw(\"return\", beforeExpr)\nkw(\"switch\")\nkw(\"throw\", beforeExpr)\nkw(\"try\")\nkw(\"var\")\nkw(\"let\")\nkw(\"const\")\nkw(\"while\", {isLoop: true})\nkw(\"with\")\nkw(\"new\", {beforeExpr: true, startsExpr: true})\nkw(\"this\", startsExpr)\nkw(\"super\", startsExpr)\nkw(\"class\")\nkw(\"extends\", beforeExpr)\nkw(\"export\")\nkw(\"import\")\nkw(\"yield\", {beforeExpr: true, startsExpr: true})\nkw(\"null\", startsExpr)\nkw(\"true\", startsExpr)\nkw(\"false\", startsExpr)\nkw(\"in\", {beforeExpr: true, binop: 7})\nkw(\"instanceof\", {beforeExpr: true, binop: 7})\nkw(\"typeof\", {beforeExpr: true, prefix: true, startsExpr: true})\nkw(\"void\", {beforeExpr: true, prefix: true, startsExpr: true})\nkw(\"delete\", {beforeExpr: true, prefix: true, startsExpr: true})\n"]}