{"version":3,"sources":["statement.js"],"names":[],"mappings":"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","file":"statement-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ### Statement parsing\n\n// Parse a program. Initializes the parser, reads any number of\n// statements, and wraps them in a Program node.  Optionally takes a\n// `program` argument.  If present, the statements will be appended\n// to its body instead of creating a new node.\n\npp.parseTopLevel = function(node) {\n  let first = true\n  if (!node.body) node.body = []\n  while (this.type !== tt.eof) {\n    let stmt = this.parseStatement(true, true)\n    node.body.push(stmt)\n    if (first) {\n      if (this.isUseStrict(stmt)) this.setStrict(true)\n      first = false\n    }\n  }\n  this.next()\n  if (this.options.ecmaVersion >= 6) {\n    node.sourceType = this.options.sourceType\n  }\n  return this.finishNode(node, \"Program\")\n}\n\nconst loopLabel = {kind: \"loop\"}, switchLabel = {kind: \"switch\"}\n\n// Parse a single statement.\n//\n// If expecting a statement and finding a slash operator, parse a\n// regular expression literal. This is to handle cases like\n// `if (foo) /blah/.exec(foo)`, where looking at the previous token\n// does not help.\n\npp.parseStatement = function(declaration, topLevel) {\n  let starttype = this.type, node = this.startNode()\n\n  // Most types of statements are recognized by the keyword they\n  // start with. Many are trivial to parse, some require a bit of\n  // complexity.\n\n  switch (starttype) {\n  case tt._break: case tt._continue: return this.parseBreakContinueStatement(node, starttype.keyword)\n  case tt._debugger: return this.parseDebuggerStatement(node)\n  case tt._do: return this.parseDoStatement(node)\n  case tt._for: return this.parseForStatement(node)\n  case tt._function:\n    if (!declaration && this.options.ecmaVersion >= 6) this.unexpected()\n    return this.parseFunctionStatement(node)\n  case tt._class:\n    if (!declaration) this.unexpected()\n    return this.parseClass(node, true)\n  case tt._if: return this.parseIfStatement(node)\n  case tt._return: return this.parseReturnStatement(node)\n  case tt._switch: return this.parseSwitchStatement(node)\n  case tt._throw: return this.parseThrowStatement(node)\n  case tt._try: return this.parseTryStatement(node)\n  case tt._let: case tt._const: if (!declaration) this.unexpected() // NOTE: falls through to _var\n  case tt._var: return this.parseVarStatement(node, starttype)\n  case tt._while: return this.parseWhileStatement(node)\n  case tt._with: return this.parseWithStatement(node)\n  case tt.braceL: return this.parseBlock()\n  case tt.semi: return this.parseEmptyStatement(node)\n  case tt._export:\n  case tt._import:\n    if (!this.options.allowImportExportEverywhere) {\n      if (!topLevel)\n        this.raise(this.start, \"'import' and 'export' may only appear at the top level\")\n      if (!this.inModule)\n        this.raise(this.start, \"'import' and 'export' may appear only with 'sourceType: module'\")\n    }\n    return starttype === tt._import ? this.parseImport(node) : this.parseExport(node)\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n  default:\n    let maybeName = this.value, expr = this.parseExpression()\n    if (starttype === tt.name && expr.type === \"Identifier\" && this.eat(tt.colon))\n      return this.parseLabeledStatement(node, maybeName, expr)\n    else return this.parseExpressionStatement(node, expr)\n  }\n}\n\npp.parseBreakContinueStatement = function(node, keyword) {\n  let isBreak = keyword == \"break\"\n  this.next()\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.label = null\n  else if (this.type !== tt.name) this.unexpected()\n  else {\n    node.label = this.parseIdent()\n    this.semicolon()\n  }\n\n  // Verify that there is an actual destination to break or\n  // continue to.\n  for (var i = 0; i < this.labels.length; ++i) {\n    let lab = this.labels[i]\n    if (node.label == null || lab.name === node.label.name) {\n      if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break\n      if (node.label && isBreak) break\n    }\n  }\n  if (i === this.labels.length) this.raise(node.start, \"Unsyntactic \" + keyword)\n  return this.finishNode(node, isBreak ? \"BreakStatement\" : \"ContinueStatement\")\n}\n\npp.parseDebuggerStatement = function(node) {\n  this.next()\n  this.semicolon()\n  return this.finishNode(node, \"DebuggerStatement\")\n}\n\npp.parseDoStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  this.expect(tt._while)\n  node.test = this.parseParenExpression()\n  if (this.options.ecmaVersion >= 6)\n    this.eat(tt.semi)\n  else\n    this.semicolon()\n  return this.finishNode(node, \"DoWhileStatement\")\n}\n\n// Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n// loop is non-trivial. Basically, we have to parse the init `var`\n// statement or expression, disallowing the `in` operator (see\n// the second parameter to `parseExpression`), and then check\n// whether the next token is `in` or `of`. When there is no init\n// part (semicolon immediately after the opening parenthesis), it\n// is a regular `for` loop.\n\npp.parseForStatement = function(node) {\n  this.next()\n  this.labels.push(loopLabel)\n  this.expect(tt.parenL)\n  if (this.type === tt.semi) return this.parseFor(node, null)\n  if (this.type === tt._var || this.type === tt._let || this.type === tt._const) {\n    let init = this.startNode(), varKind = this.type\n    this.next()\n    this.parseVar(init, true, varKind)\n    this.finishNode(init, \"VariableDeclaration\")\n    if ((this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) && init.declarations.length === 1 &&\n        !(varKind !== tt._var && init.declarations[0].init))\n      return this.parseForIn(node, init)\n    return this.parseFor(node, init)\n  }\n  let refDestructuringErrors = {shorthandAssign: 0, trailingComma: 0}\n  let init = this.parseExpression(true, refDestructuringErrors)\n  if (this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\"))) {\n    this.checkPatternErrors(refDestructuringErrors, true)\n    this.toAssignable(init)\n    this.checkLVal(init)\n    return this.parseForIn(node, init)\n  } else {\n    this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return this.parseFor(node, init)\n}\n\npp.parseFunctionStatement = function(node) {\n  this.next()\n  return this.parseFunction(node, true)\n}\n\npp.parseIfStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  node.consequent = this.parseStatement(false)\n  node.alternate = this.eat(tt._else) ? this.parseStatement(false) : null\n  return this.finishNode(node, \"IfStatement\")\n}\n\npp.parseReturnStatement = function(node) {\n  if (!this.inFunction && !this.options.allowReturnOutsideFunction)\n    this.raise(this.start, \"'return' outside of function\")\n  this.next()\n\n  // In `return` (and `break`/`continue`), the keywords with\n  // optional arguments, we eagerly look for a semicolon or the\n  // possibility to insert one.\n\n  if (this.eat(tt.semi) || this.insertSemicolon()) node.argument = null\n  else { node.argument = this.parseExpression(); this.semicolon() }\n  return this.finishNode(node, \"ReturnStatement\")\n}\n\npp.parseSwitchStatement = function(node) {\n  this.next()\n  node.discriminant = this.parseParenExpression()\n  node.cases = []\n  this.expect(tt.braceL)\n  this.labels.push(switchLabel)\n\n  // Statements under must be grouped (by label) in SwitchCase\n  // nodes. `cur` is used to keep the node that we are currently\n  // adding statements to.\n\n  for (var cur, sawDefault = false; this.type != tt.braceR;) {\n    if (this.type === tt._case || this.type === tt._default) {\n      let isCase = this.type === tt._case\n      if (cur) this.finishNode(cur, \"SwitchCase\")\n      node.cases.push(cur = this.startNode())\n      cur.consequent = []\n      this.next()\n      if (isCase) {\n        cur.test = this.parseExpression()\n      } else {\n        if (sawDefault) this.raise(this.lastTokStart, \"Multiple default clauses\")\n        sawDefault = true\n        cur.test = null\n      }\n      this.expect(tt.colon)\n    } else {\n      if (!cur) this.unexpected()\n      cur.consequent.push(this.parseStatement(true))\n    }\n  }\n  if (cur) this.finishNode(cur, \"SwitchCase\")\n  this.next() // Closing brace\n  this.labels.pop()\n  return this.finishNode(node, \"SwitchStatement\")\n}\n\npp.parseThrowStatement = function(node) {\n  this.next()\n  if (lineBreak.test(this.input.slice(this.lastTokEnd, this.start)))\n    this.raise(this.lastTokEnd, \"Illegal newline after throw\")\n  node.argument = this.parseExpression()\n  this.semicolon()\n  return this.finishNode(node, \"ThrowStatement\")\n}\n\n// Reused empty array added for node fields that are always empty.\n\nconst empty = []\n\npp.parseTryStatement = function(node) {\n  this.next()\n  node.block = this.parseBlock()\n  node.handler = null\n  if (this.type === tt._catch) {\n    let clause = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    clause.param = this.parseBindingAtom()\n    this.checkLVal(clause.param, true)\n    this.expect(tt.parenR)\n    clause.body = this.parseBlock()\n    node.handler = this.finishNode(clause, \"CatchClause\")\n  }\n  node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null\n  if (!node.handler && !node.finalizer)\n    this.raise(node.start, \"Missing catch or finally clause\")\n  return this.finishNode(node, \"TryStatement\")\n}\n\npp.parseVarStatement = function(node, kind) {\n  this.next()\n  this.parseVar(node, false, kind)\n  this.semicolon()\n  return this.finishNode(node, \"VariableDeclaration\")\n}\n\npp.parseWhileStatement = function(node) {\n  this.next()\n  node.test = this.parseParenExpression()\n  this.labels.push(loopLabel)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"WhileStatement\")\n}\n\npp.parseWithStatement = function(node) {\n  if (this.strict) this.raise(this.start, \"'with' in strict mode\")\n  this.next()\n  node.object = this.parseParenExpression()\n  node.body = this.parseStatement(false)\n  return this.finishNode(node, \"WithStatement\")\n}\n\npp.parseEmptyStatement = function(node) {\n  this.next()\n  return this.finishNode(node, \"EmptyStatement\")\n}\n\npp.parseLabeledStatement = function(node, maybeName, expr) {\n  for (let i = 0; i < this.labels.length; ++i)\n    if (this.labels[i].name === maybeName) this.raise(expr.start, \"Label '\" + maybeName + \"' is already declared\")\n  let kind = this.type.isLoop ? \"loop\" : this.type === tt._switch ? \"switch\" : null\n  for (let i = this.labels.length - 1; i >= 0; i--) {\n    let label = this.labels[i]\n    if (label.statementStart == node.start) {\n      label.statementStart = this.start;\n      label.kind = kind;\n    } else break;\n  }\n  this.labels.push({name: maybeName, kind: kind, statementStart: this.start})\n  node.body = this.parseStatement(true)\n  this.labels.pop()\n  node.label = expr\n  return this.finishNode(node, \"LabeledStatement\")\n}\n\npp.parseExpressionStatement = function(node, expr) {\n  node.expression = expr\n  this.semicolon()\n  return this.finishNode(node, \"ExpressionStatement\")\n}\n\n// Parse a semicolon-enclosed block of statements, handling `\"use\n// strict\"` declarations when `allowStrict` is true (used for\n// function bodies).\n\npp.parseBlock = function(allowStrict) {\n  let node = this.startNode(), first = true, oldStrict\n  node.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    let stmt = this.parseStatement(true)\n    node.body.push(stmt)\n    if (first && allowStrict && this.isUseStrict(stmt)) {\n      oldStrict = this.strict\n      this.setStrict(this.strict = true)\n    }\n    first = false\n  }\n  if (oldStrict === false) this.setStrict(false)\n  return this.finishNode(node, \"BlockStatement\")\n}\n\n// Parse a regular `for` loop. The disambiguation code in\n// `parseStatement` will already have parsed the init statement or\n// expression.\n\npp.parseFor = function(node, init) {\n  node.init = init\n  this.expect(tt.semi)\n  node.test = this.type === tt.semi ? null : this.parseExpression()\n  this.expect(tt.semi)\n  node.update = this.type === tt.parenR ? null : this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, \"ForStatement\")\n}\n\n// Parse a `for`/`in` and `for`/`of` loop, which are almost\n// same from parser's perspective.\n\npp.parseForIn = function(node, init) {\n  let type = this.type === tt._in ? \"ForInStatement\" : \"ForOfStatement\"\n  this.next()\n  node.left = init\n  node.right = this.parseExpression()\n  this.expect(tt.parenR)\n  node.body = this.parseStatement(false)\n  this.labels.pop()\n  return this.finishNode(node, type)\n}\n\n// Parse a list of variable declarations.\n\npp.parseVar = function(node, isFor, kind) {\n  node.declarations = []\n  node.kind = kind.keyword\n  for (;;) {\n    let decl = this.startNode()\n    this.parseVarId(decl)\n    if (this.eat(tt.eq)) {\n      decl.init = this.parseMaybeAssign(isFor)\n    } else if (kind === tt._const && !(this.type === tt._in || (this.options.ecmaVersion >= 6 && this.isContextual(\"of\")))) {\n      this.unexpected()\n    } else if (decl.id.type != \"Identifier\" && !(isFor && (this.type === tt._in || this.isContextual(\"of\")))) {\n      this.raise(this.lastTokEnd, \"Complex binding patterns require an initialization value\")\n    } else {\n      decl.init = null\n    }\n    node.declarations.push(this.finishNode(decl, \"VariableDeclarator\"))\n    if (!this.eat(tt.comma)) break\n  }\n  return node\n}\n\npp.parseVarId = function(decl) {\n  decl.id = this.parseBindingAtom()\n  this.checkLVal(decl.id, true)\n}\n\n// Parse a function declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseFunction = function(node, isStatement, allowExpressionBody) {\n  this.initFunction(node)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = this.eat(tt.star)\n  if (isStatement || this.type === tt.name)\n    node.id = this.parseIdent()\n  this.parseFunctionParams(node)\n  this.parseFunctionBody(node, allowExpressionBody)\n  return this.finishNode(node, isStatement ? \"FunctionDeclaration\" : \"FunctionExpression\")\n}\n\npp.parseFunctionParams = function(node) {\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false, true)\n}\n\n// Parse a class declaration or literal (depending on the\n// `isStatement` parameter).\n\npp.parseClass = function(node, isStatement) {\n  this.next()\n  this.parseClassId(node, isStatement)\n  this.parseClassSuper(node)\n  let classBody = this.startNode()\n  let hadConstructor = false\n  classBody.body = []\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (this.eat(tt.semi)) continue\n    let method = this.startNode()\n    let isGenerator = this.eat(tt.star)\n    let isMaybeStatic = this.type === tt.name && this.value === \"static\"\n    this.parsePropertyName(method)\n    method.static = isMaybeStatic && this.type !== tt.parenL\n    if (method.static) {\n      if (isGenerator) this.unexpected()\n      isGenerator = this.eat(tt.star)\n      this.parsePropertyName(method)\n    }\n    method.kind = \"method\"\n    let isGetSet = false\n    if (!method.computed) {\n      let {key} = method\n      if (!isGenerator && key.type === \"Identifier\" && this.type !== tt.parenL && (key.name === \"get\" || key.name === \"set\")) {\n        isGetSet = true\n        method.kind = key.name\n        key = this.parsePropertyName(method)\n      }\n      if (!method.static && (key.type === \"Identifier\" && key.name === \"constructor\" ||\n          key.type === \"Literal\" && key.value === \"constructor\")) {\n        if (hadConstructor) this.raise(key.start, \"Duplicate constructor in the same class\")\n        if (isGetSet) this.raise(key.start, \"Constructor can't have get/set modifier\")\n        if (isGenerator) this.raise(key.start, \"Constructor can't be a generator\")\n        method.kind = \"constructor\"\n        hadConstructor = true\n      }\n    }\n    this.parseClassMethod(classBody, method, isGenerator)\n    if (isGetSet) {\n      let paramCount = method.kind === \"get\" ? 0 : 1\n      if (method.value.params.length !== paramCount) {\n        let start = method.value.start\n        if (method.kind === \"get\")\n          this.raise(start, \"getter should have no params\");\n        else\n          this.raise(start, \"setter should have exactly one param\")\n      }\n      if (method.kind === \"set\" && method.value.params[0].type === \"RestElement\")\n        this.raise(method.value.params[0].start, \"Setter cannot use rest params\")\n    }\n  }\n  node.body = this.finishNode(classBody, \"ClassBody\")\n  return this.finishNode(node, isStatement ? \"ClassDeclaration\" : \"ClassExpression\")\n}\n\npp.parseClassMethod = function(classBody, method, isGenerator) {\n  method.value = this.parseMethod(isGenerator)\n  classBody.body.push(this.finishNode(method, \"MethodDefinition\"))\n}\n\npp.parseClassId = function(node, isStatement) {\n  node.id = this.type === tt.name ? this.parseIdent() : isStatement ? this.unexpected() : null\n}\n\npp.parseClassSuper = function(node) {\n  node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null\n}\n\n// Parses module export declaration.\n\npp.parseExport = function(node) {\n  this.next()\n  // export * from '...'\n  if (this.eat(tt.star)) {\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    this.semicolon()\n    return this.finishNode(node, \"ExportAllDeclaration\")\n  }\n  if (this.eat(tt._default)) { // export default ...\n    let expr = this.parseMaybeAssign()\n    let needsSemi = true\n    if (expr.type == \"FunctionExpression\" ||\n        expr.type == \"ClassExpression\") {\n      needsSemi = false\n      if (expr.id) {\n        expr.type = expr.type == \"FunctionExpression\"\n          ? \"FunctionDeclaration\"\n          : \"ClassDeclaration\"\n      }\n    }\n    node.declaration = expr\n    if (needsSemi) this.semicolon()\n    return this.finishNode(node, \"ExportDefaultDeclaration\")\n  }\n  // export var|const|let|function|class ...\n  if (this.shouldParseExportStatement()) {\n    node.declaration = this.parseStatement(true)\n    node.specifiers = []\n    node.source = null\n  } else { // export { x, y as z } [from '...']\n    node.declaration = null\n    node.specifiers = this.parseExportSpecifiers()\n    if (this.eatContextual(\"from\")) {\n      node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n    } else {\n      // check for keywords used as local names\n      for (let i = 0; i < node.specifiers.length; i++) {\n        if (this.keywords.test(node.specifiers[i].local.name) || this.reservedWords.test(node.specifiers[i].local.name)) {\n          this.unexpected(node.specifiers[i].local.start)\n        }\n      }\n\n      node.source = null\n    }\n    this.semicolon()\n  }\n  return this.finishNode(node, \"ExportNamedDeclaration\")\n}\n\npp.shouldParseExportStatement = function() {\n  return this.type.keyword\n}\n\n// Parses a comma-separated list of module exports.\n\npp.parseExportSpecifiers = function() {\n  let nodes = [], first = true\n  // export { x, y as z } [from '...']\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.local = this.parseIdent(this.type === tt._default)\n    node.exported = this.eatContextual(\"as\") ? this.parseIdent(true) : node.local\n    nodes.push(this.finishNode(node, \"ExportSpecifier\"))\n  }\n  return nodes\n}\n\n// Parses import declaration.\n\npp.parseImport = function(node) {\n  this.next()\n  // import '...'\n  if (this.type === tt.string) {\n    node.specifiers = empty\n    node.source = this.parseExprAtom()\n  } else {\n    node.specifiers = this.parseImportSpecifiers()\n    this.expectContextual(\"from\")\n    node.source = this.type === tt.string ? this.parseExprAtom() : this.unexpected()\n  }\n  this.semicolon()\n  return this.finishNode(node, \"ImportDeclaration\")\n}\n\n// Parses a comma-separated list of module imports.\n\npp.parseImportSpecifiers = function() {\n  let nodes = [], first = true\n  if (this.type === tt.name) {\n    // import defaultObj, { x, y as z } from '...'\n    let node = this.startNode()\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportDefaultSpecifier\"))\n    if (!this.eat(tt.comma)) return nodes\n  }\n  if (this.type === tt.star) {\n    let node = this.startNode()\n    this.next()\n    this.expectContextual(\"as\")\n    node.local = this.parseIdent()\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportNamespaceSpecifier\"))\n    return nodes\n  }\n  this.expect(tt.braceL)\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let node = this.startNode()\n    node.imported = this.parseIdent(true)\n    if (this.eatContextual(\"as\")) {\n      node.local = this.parseIdent()\n    } else {\n      node.local = node.imported\n      if (this.isKeyword(node.local.name)) this.unexpected(node.local.start)\n      if (this.reservedWordsStrict.test(node.local.name)) this.raise(node.local.start, \"The keyword '\" + node.local.name + \"' is reserved\")\n    }\n    this.checkLVal(node.local, true)\n    nodes.push(this.finishNode(node, \"ImportSpecifier\"))\n  }\n  return nodes\n}\n"]}