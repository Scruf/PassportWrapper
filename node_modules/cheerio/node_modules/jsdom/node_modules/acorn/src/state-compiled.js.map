{"version":3,"sources":["state.js"],"names":[],"mappings":"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","file":"state-compiled.js","sourcesContent":["import {reservedWords, keywords} from \"./identifier\"\nimport {types as tt} from \"./tokentype\"\nimport {lineBreak} from \"./whitespace\"\nimport {getOptions} from \"./options\"\n\n// Registered plugins\nexport const plugins = {}\n\nfunction keywordRegexp(words) {\n  return new RegExp(\"^(\" + words.replace(/ /g, \"|\") + \")$\")\n}\n\nexport class Parser {\n  constructor(options, input, startPos) {\n    this.options = options = getOptions(options)\n    this.sourceFile = options.sourceFile\n    this.keywords = keywordRegexp(keywords[options.ecmaVersion >= 6 ? 6 : 5])\n    let reserved = options.allowReserved ? \"\" :\n        reservedWords[options.ecmaVersion] + (options.sourceType == \"module\" ? \" await\" : \"\")\n    this.reservedWords = keywordRegexp(reserved)\n    let reservedStrict = (reserved ? reserved + \" \" : \"\") + reservedWords.strict\n    this.reservedWordsStrict = keywordRegexp(reservedStrict)\n    this.reservedWordsStrictBind = keywordRegexp(reservedStrict + \" \" + reservedWords.strictBind)\n    this.input = String(input)\n\n    // Used to signal to callers of `readWord1` whether the word\n    // contained any escape sequences. This is needed because words with\n    // escape sequences must not be interpreted as keywords.\n    this.containsEsc = false;\n\n    // Load plugins\n    this.loadPlugins(options.plugins)\n\n    // Set up token state\n\n    // The current position of the tokenizer in the input.\n    if (startPos) {\n      this.pos = startPos\n      this.lineStart = Math.max(0, this.input.lastIndexOf(\"\\n\", startPos))\n      this.curLine = this.input.slice(0, this.lineStart).split(lineBreak).length\n    } else {\n      this.pos = this.lineStart = 0\n      this.curLine = 1\n    }\n\n    // Properties of the current token:\n    // Its type\n    this.type = tt.eof\n    // For tokens that include more information than their type, the value\n    this.value = null\n    // Its start and end offset\n    this.start = this.end = this.pos\n    // And, if locations are used, the {line, column} object\n    // corresponding to those offsets\n    this.startLoc = this.endLoc = this.curPosition()\n\n    // Position information for the previous token\n    this.lastTokEndLoc = this.lastTokStartLoc = null\n    this.lastTokStart = this.lastTokEnd = this.pos\n\n    // The context stack is used to superficially track syntactic\n    // context to predict whether a regular expression is allowed in a\n    // given position.\n    this.context = this.initialContext()\n    this.exprAllowed = true\n\n    // Figure out if it's a module code.\n    this.strict = this.inModule = options.sourceType === \"module\"\n\n    // Used to signify the start of a potential arrow function\n    this.potentialArrowAt = -1\n\n    // Flags to track whether we are in a function, a generator.\n    this.inFunction = this.inGenerator = false\n    // Labels in scope.\n    this.labels = []\n\n    // If enabled, skip leading hashbang line.\n    if (this.pos === 0 && options.allowHashBang && this.input.slice(0, 2) === '#!')\n      this.skipLineComment(2)\n  }\n\n  // DEPRECATED Kept for backwards compatibility until 3.0 in case a plugin uses them\n  isKeyword(word) { return this.keywords.test(word) }\n  isReservedWord(word) { return this.reservedWords.test(word) }\n\n  extend(name, f) {\n    this[name] = f(this[name])\n  }\n\n  loadPlugins(pluginConfigs) {\n    for (let name in pluginConfigs) {\n      let plugin = plugins[name]\n      if (!plugin) throw new Error(\"Plugin '\" + name + \"' not found\")\n      plugin(this, pluginConfigs[name])\n    }\n  }\n\n  parse() {\n    let node = this.options.program || this.startNode()\n    this.nextToken()\n    return this.parseTopLevel(node)\n  }\n}\n"]}