{"version":3,"sources":["index.js"],"names":[],"mappings":"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","file":"index-compiled.js","sourcesContent":["// AST walker module for Mozilla Parser API compatible trees\n\n// A simple walk is one where you simply specify callbacks to be\n// called on specific nodes. The last two arguments are optional. A\n// simple use would be\n//\n//     walk.simple(myTree, {\n//         Expression: function(node) { ... }\n//     });\n//\n// to do something with all expressions. All Parser API node types\n// can be used to identify node types, as well as Expression,\n// Statement, and ScopeBody, which denote categories of nodes.\n//\n// The base argument can be used to pass a custom (recursive)\n// walker, and state can be used to give this walked an initial\n// state.\n\nexport function simple(node, visitors, base, state, override) {\n  if (!base) base = exports.base\n  ;(function c(node, st, override) {\n    let type = override || node.type, found = visitors[type]\n    base[type](node, st, c)\n    if (found) found(node, st)\n  })(node, state, override)\n}\n\n// An ancestor walk builds up an array of ancestor nodes (including\n// the current node) and passes them to the callback as the state parameter.\nexport function ancestor(node, visitors, base, state) {\n  if (!base) base = exports.base\n  if (!state) state = []\n  ;(function c(node, st, override) {\n    let type = override || node.type, found = visitors[type]\n    if (node != st[st.length - 1]) {\n      st = st.slice()\n      st.push(node)\n    }\n    base[type](node, st, c)\n    if (found) found(node, st)\n  })(node, state)\n}\n\n// A recursive walk is one where your functions override the default\n// walkers. They can modify and replace the state parameter that's\n// threaded through the walk, and can opt how and whether to walk\n// their child nodes (by calling their third argument on these\n// nodes).\nexport function recursive(node, state, funcs, base, override) {\n  let visitor = funcs ? exports.make(funcs, base) : base\n  ;(function c(node, st, override) {\n    visitor[override || node.type](node, st, c)\n  })(node, state, override)\n}\n\nfunction makeTest(test) {\n  if (typeof test == \"string\")\n    return type => type == test\n  else if (!test)\n    return () => true\n  else\n    return test\n}\n\nclass Found {\n  constructor(node, state) { this.node = node; this.state = state }\n}\n\n// Find a node with a given start, end, and type (all are optional,\n// null can be used as wildcard). Returns a {node, state} object, or\n// undefined when it doesn't find a matching node.\nexport function findNodeAt(node, start, end, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      let type = override || node.type\n      if ((start == null || node.start <= start) &&\n          (end == null || node.end >= end))\n        base[type](node, st, c)\n      if ((start == null || node.start == start) &&\n          (end == null || node.end == end) &&\n          test(type, node))\n        throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the innermost node of a given type that contains the given\n// position. Interface similar to findNodeAt.\nexport function findNodeAround(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      let type = override || node.type\n      if (node.start > pos || node.end < pos) return\n      base[type](node, st, c)\n      if (test(type, node)) throw new Found(node, st)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node after a given position.\nexport function findNodeAfter(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  try {\n    ;(function c(node, st, override) {\n      if (node.end < pos) return\n      let type = override || node.type\n      if (node.start >= pos && test(type, node)) throw new Found(node, st)\n      base[type](node, st, c)\n    })(node, state)\n  } catch (e) {\n    if (e instanceof Found) return e\n    throw e\n  }\n}\n\n// Find the outermost matching node before a given position.\nexport function findNodeBefore(node, pos, test, base, state) {\n  test = makeTest(test)\n  if (!base) base = exports.base\n  let max\n  ;(function c(node, st, override) {\n    if (node.start > pos) return\n    let type = override || node.type\n    if (node.end <= pos && (!max || max.node.end < node.end) && test(type, node))\n      max = new Found(node, st)\n    base[type](node, st, c)\n  })(node, state)\n  return max\n}\n\n// Used to create a custom walker. Will fill in all missing node\n// type properties with the defaults.\nexport function make(funcs, base) {\n  if (!base) base = exports.base\n  let visitor = {}\n  for (var type in base) visitor[type] = base[type]\n  for (var type in funcs) visitor[type] = funcs[type]\n  return visitor\n}\n\nfunction skipThrough(node, st, c) { c(node, st) }\nfunction ignore(_node, _st, _c) {}\n\n// Node walkers.\n\nexport const base = {}\n\nbase.Program = base.BlockStatement = (node, st, c) => {\n  for (let i = 0; i < node.body.length; ++i)\n    c(node.body[i], st, \"Statement\")\n}\nbase.Statement = skipThrough\nbase.EmptyStatement = ignore\nbase.ExpressionStatement = base.ParenthesizedExpression =\n  (node, st, c) => c(node.expression, st, \"Expression\")\nbase.IfStatement = (node, st, c) => {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Statement\")\n  if (node.alternate) c(node.alternate, st, \"Statement\")\n}\nbase.LabeledStatement = (node, st, c) => c(node.body, st, \"Statement\")\nbase.BreakStatement = base.ContinueStatement = ignore\nbase.WithStatement = (node, st, c) => {\n  c(node.object, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.SwitchStatement = (node, st, c) => {\n  c(node.discriminant, st, \"Expression\")\n  for (let i = 0; i < node.cases.length; ++i) {\n    let cs = node.cases[i]\n    if (cs.test) c(cs.test, st, \"Expression\")\n    for (let j = 0; j < cs.consequent.length; ++j)\n      c(cs.consequent[j], st, \"Statement\")\n  }\n}\nbase.ReturnStatement = base.YieldExpression = (node, st, c) => {\n  if (node.argument) c(node.argument, st, \"Expression\")\n}\nbase.ThrowStatement = base.SpreadElement =\n  (node, st, c) => c(node.argument, st, \"Expression\")\nbase.TryStatement = (node, st, c) => {\n  c(node.block, st, \"Statement\")\n  if (node.handler) {\n    c(node.handler.param, st, \"Pattern\")\n    c(node.handler.body, st, \"ScopeBody\")\n  }\n  if (node.finalizer) c(node.finalizer, st, \"Statement\")\n}\nbase.WhileStatement = base.DoWhileStatement = (node, st, c) => {\n  c(node.test, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForStatement = (node, st, c) => {\n  if (node.init) c(node.init, st, \"ForInit\")\n  if (node.test) c(node.test, st, \"Expression\")\n  if (node.update) c(node.update, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInStatement = base.ForOfStatement = (node, st, c) => {\n  c(node.left, st, \"ForInit\")\n  c(node.right, st, \"Expression\")\n  c(node.body, st, \"Statement\")\n}\nbase.ForInit = (node, st, c) => {\n  if (node.type == \"VariableDeclaration\") c(node, st)\n  else c(node, st, \"Expression\")\n}\nbase.DebuggerStatement = ignore\n\nbase.FunctionDeclaration = (node, st, c) => c(node, st, \"Function\")\nbase.VariableDeclaration = (node, st, c) => {\n  for (let i = 0; i < node.declarations.length; ++i)\n    c(node.declarations[i], st)\n}\nbase.VariableDeclarator = (node, st, c) => {\n  c(node.id, st, \"Pattern\")\n  if (node.init) c(node.init, st, \"Expression\")\n}\n\nbase.Function = (node, st, c) => {\n  if (node.id) c(node.id, st, \"Pattern\")\n  for (let i = 0; i < node.params.length; i++)\n    c(node.params[i], st, \"Pattern\")\n  c(node.body, st, node.expression ? \"ScopeExpression\" : \"ScopeBody\")\n}\n// FIXME drop these node types in next major version\n// (They are awkward, and in ES6 every block can be a scope.)\nbase.ScopeBody = (node, st, c) => c(node, st, \"Statement\")\nbase.ScopeExpression = (node, st, c) => c(node, st, \"Expression\")\n\nbase.Pattern = (node, st, c) => {\n  if (node.type == \"Identifier\")\n    c(node, st, \"VariablePattern\")\n  else if (node.type == \"MemberExpression\")\n    c(node, st, \"MemberPattern\")\n  else\n    c(node, st)\n}\nbase.VariablePattern = ignore\nbase.MemberPattern = skipThrough\nbase.RestElement = (node, st, c) => c(node.argument, st, \"Pattern\")\nbase.ArrayPattern =  (node, st, c) => {\n  for (let i = 0; i < node.elements.length; ++i) {\n    let elt = node.elements[i]\n    if (elt) c(elt, st, \"Pattern\")\n  }\n}\nbase.ObjectPattern = (node, st, c) => {\n  for (let i = 0; i < node.properties.length; ++i)\n    c(node.properties[i].value, st, \"Pattern\")\n}\n\nbase.Expression = skipThrough\nbase.ThisExpression = base.Super = base.MetaProperty = ignore\nbase.ArrayExpression = (node, st, c) => {\n  for (let i = 0; i < node.elements.length; ++i) {\n    let elt = node.elements[i]\n    if (elt) c(elt, st, \"Expression\")\n  }\n}\nbase.ObjectExpression = (node, st, c) => {\n  for (let i = 0; i < node.properties.length; ++i)\n    c(node.properties[i], st)\n}\nbase.FunctionExpression = base.ArrowFunctionExpression = base.FunctionDeclaration\nbase.SequenceExpression = base.TemplateLiteral = (node, st, c) => {\n  for (let i = 0; i < node.expressions.length; ++i)\n    c(node.expressions[i], st, \"Expression\")\n}\nbase.UnaryExpression = base.UpdateExpression = (node, st, c) => {\n  c(node.argument, st, \"Expression\")\n}\nbase.BinaryExpression = base.LogicalExpression = (node, st, c) => {\n  c(node.left, st, \"Expression\")\n  c(node.right, st, \"Expression\")\n}\nbase.AssignmentExpression = base.AssignmentPattern = (node, st, c) => {\n  c(node.left, st, \"Pattern\")\n  c(node.right, st, \"Expression\")\n}\nbase.ConditionalExpression = (node, st, c) => {\n  c(node.test, st, \"Expression\")\n  c(node.consequent, st, \"Expression\")\n  c(node.alternate, st, \"Expression\")\n}\nbase.NewExpression = base.CallExpression = (node, st, c) => {\n  c(node.callee, st, \"Expression\")\n  if (node.arguments) for (let i = 0; i < node.arguments.length; ++i)\n    c(node.arguments[i], st, \"Expression\")\n}\nbase.MemberExpression = (node, st, c) => {\n  c(node.object, st, \"Expression\")\n  if (node.computed) c(node.property, st, \"Expression\")\n}\nbase.ExportNamedDeclaration = base.ExportDefaultDeclaration = (node, st, c) => {\n  if (node.declaration)\n    c(node.declaration, st, node.type == \"ExportNamedDeclaration\" || node.declaration.id ? \"Statement\" : \"Expression\")\n  if (node.source) c(node.source, st, \"Expression\")\n}\nbase.ExportAllDeclaration = (node, st, c) => {\n  c(node.source, st, \"Expression\")\n}\nbase.ImportDeclaration = (node, st, c) => {\n  for (let i = 0; i < node.specifiers.length; i++)\n    c(node.specifiers[i], st)\n  c(node.source, st, \"Expression\")\n}\nbase.ImportSpecifier = base.ImportDefaultSpecifier = base.ImportNamespaceSpecifier = base.Identifier = base.Literal = ignore\n\nbase.TaggedTemplateExpression = (node, st, c) => {\n  c(node.tag, st, \"Expression\")\n  c(node.quasi, st)\n}\nbase.ClassDeclaration = base.ClassExpression = (node, st, c) => c(node, st, \"Class\")\nbase.Class = (node, st, c) => {\n  if (node.id) c(node.id, st, \"Pattern\")\n  if (node.superClass) c(node.superClass, st, \"Expression\")\n  for (let i = 0; i < node.body.body.length; i++)\n    c(node.body.body[i], st)\n}\nbase.MethodDefinition = base.Property = (node, st, c) => {\n  if (node.computed) c(node.key, st, \"Expression\")\n  c(node.value, st, \"Expression\")\n}\nbase.ComprehensionExpression = (node, st, c) => {\n  for (let i = 0; i < node.blocks.length; i++)\n    c(node.blocks[i].right, st, \"Expression\")\n  c(node.body, st, \"Expression\")\n}\n"]}