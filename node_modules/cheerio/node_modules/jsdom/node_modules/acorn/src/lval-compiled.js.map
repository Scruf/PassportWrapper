{"version":3,"sources":["lval.js"],"names":[],"mappings":"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","file":"lval-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {has} from \"./util\"\n\nconst pp = Parser.prototype\n\n// Convert existing expression atom to assignable pattern\n// if possible.\n\npp.toAssignable = function(node, isBinding) {\n  if (this.options.ecmaVersion >= 6 && node) {\n    switch (node.type) {\n    case \"Identifier\":\n    case \"ObjectPattern\":\n    case \"ArrayPattern\":\n      break\n\n    case \"ObjectExpression\":\n      node.type = \"ObjectPattern\"\n      for (let i = 0; i < node.properties.length; i++) {\n        let prop = node.properties[i]\n        if (prop.kind !== \"init\") this.raise(prop.key.start, \"Object pattern can't contain getter or setter\")\n        this.toAssignable(prop.value, isBinding)\n      }\n      break\n\n    case \"ArrayExpression\":\n      node.type = \"ArrayPattern\"\n      this.toAssignableList(node.elements, isBinding)\n      break\n\n    case \"AssignmentExpression\":\n      if (node.operator === \"=\") {\n        node.type = \"AssignmentPattern\"\n        delete node.operator\n        // falls through to AssignmentPattern\n      } else {\n        this.raise(node.left.end, \"Only '=' operator can be used for specifying default value.\")\n        break;\n      }\n\n    case \"AssignmentPattern\":\n      if (node.right.type === \"YieldExpression\")\n        this.raise(node.right.start, \"Yield expression cannot be a default value\")\n      break;\n\n    case \"ParenthesizedExpression\":\n      node.expression = this.toAssignable(node.expression, isBinding)\n      break\n\n    case \"MemberExpression\":\n      if (!isBinding) break\n\n    default:\n      this.raise(node.start, \"Assigning to rvalue\")\n    }\n  }\n  return node\n}\n\n// Convert list of expression atoms to binding list.\n\npp.toAssignableList = function(exprList, isBinding) {\n  let end = exprList.length\n  if (end) {\n    let last = exprList[end - 1]\n    if (last && last.type == \"RestElement\") {\n      --end\n    } else if (last && last.type == \"SpreadElement\") {\n      last.type = \"RestElement\"\n      let arg = last.argument\n      this.toAssignable(arg, isBinding)\n      if (arg.type !== \"Identifier\" && arg.type !== \"MemberExpression\" && arg.type !== \"ArrayPattern\")\n        this.unexpected(arg.start)\n      --end\n    }\n\n    if (isBinding && last.type === \"RestElement\" && last.argument.type !== \"Identifier\")\n      this.unexpected(last.argument.start);\n  }\n  for (let i = 0; i < end; i++) {\n    let elt = exprList[i]\n    if (elt) this.toAssignable(elt, isBinding)\n  }\n  return exprList\n}\n\n// Parses spread element.\n\npp.parseSpread = function(refDestructuringErrors) {\n  let node = this.startNode()\n  this.next()\n  node.argument = this.parseMaybeAssign(refDestructuringErrors)\n  return this.finishNode(node, \"SpreadElement\")\n}\n\npp.parseRest = function(allowNonIdent) {\n  let node = this.startNode()\n  this.next()\n\n  // RestElement inside of a function parameter must be an identifier\n  if (allowNonIdent) node.argument = this.type === tt.name ? this.parseIdent() : this.unexpected()\n  else node.argument = this.type === tt.name || this.type === tt.bracketL ? this.parseBindingAtom() : this.unexpected()\n\n  return this.finishNode(node, \"RestElement\")\n}\n\n// Parses lvalue (assignable) atom.\n\npp.parseBindingAtom = function() {\n  if (this.options.ecmaVersion < 6) return this.parseIdent()\n  switch (this.type) {\n  case tt.name:\n    return this.parseIdent()\n\n  case tt.bracketL:\n    let node = this.startNode()\n    this.next()\n    node.elements = this.parseBindingList(tt.bracketR, true, true)\n    return this.finishNode(node, \"ArrayPattern\")\n\n  case tt.braceL:\n    return this.parseObj(true)\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseBindingList = function(close, allowEmpty, allowTrailingComma, allowNonIdent) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (first) first = false\n    else this.expect(tt.comma)\n    if (allowEmpty && this.type === tt.comma) {\n      elts.push(null)\n    } else if (allowTrailingComma && this.afterTrailingComma(close)) {\n      break\n    } else if (this.type === tt.ellipsis) {\n      let rest = this.parseRest(allowNonIdent)\n      this.parseBindingListItem(rest)\n      elts.push(rest)\n      this.expect(close)\n      break\n    } else {\n      let elem = this.parseMaybeDefault(this.start, this.startLoc)\n      this.parseBindingListItem(elem)\n      elts.push(elem)\n    }\n  }\n  return elts\n}\n\npp.parseBindingListItem = function(param) {\n  return param\n}\n\n// Parses assignment pattern around given atom if possible.\n\npp.parseMaybeDefault = function(startPos, startLoc, left) {\n  left = left || this.parseBindingAtom()\n  if (this.options.ecmaVersion < 6 || !this.eat(tt.eq)) return left\n  let node = this.startNodeAt(startPos, startLoc)\n  node.left = left\n  node.right = this.parseMaybeAssign()\n  return this.finishNode(node, \"AssignmentPattern\")\n}\n\n// Verify that a node is an lval — something that can be assigned\n// to.\n\npp.checkLVal = function(expr, isBinding, checkClashes) {\n  switch (expr.type) {\n  case \"Identifier\":\n    if (this.strict && this.reservedWordsStrictBind.test(expr.name))\n      this.raise(expr.start, (isBinding ? \"Binding \" : \"Assigning to \") + expr.name + \" in strict mode\")\n    if (checkClashes) {\n      if (has(checkClashes, expr.name))\n        this.raise(expr.start, \"Argument name clash\")\n      checkClashes[expr.name] = true\n    }\n    break\n\n  case \"MemberExpression\":\n    if (isBinding) this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" member expression\")\n    break\n\n  case \"ObjectPattern\":\n    for (let i = 0; i < expr.properties.length; i++)\n      this.checkLVal(expr.properties[i].value, isBinding, checkClashes)\n    break\n\n  case \"ArrayPattern\":\n    for (let i = 0; i < expr.elements.length; i++) {\n      let elem = expr.elements[i]\n      if (elem) this.checkLVal(elem, isBinding, checkClashes)\n    }\n    break\n\n  case \"AssignmentPattern\":\n    this.checkLVal(expr.left, isBinding, checkClashes)\n    break\n\n  case \"RestElement\":\n    this.checkLVal(expr.argument, isBinding, checkClashes)\n    break\n\n  case \"ParenthesizedExpression\":\n    this.checkLVal(expr.expression, isBinding, checkClashes)\n    break\n\n  default:\n    this.raise(expr.start, (isBinding ? \"Binding\" : \"Assigning to\") + \" rvalue\")\n  }\n}\n"]}