{"version":3,"sources":["expression.js"],"names":[],"mappings":"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","file":"expression-compiled.js","sourcesContent":["// A recursive descent parser operates by defining functions for all\n// syntactic elements, and recursively calling those, each function\n// advancing the input stream and returning an AST node. Precedence\n// of constructs (for example, the fact that `!x[1]` means `!(x[1])`\n// instead of `(!x)[1]` is handled by the fact that the parser\n// function that parses unary prefix operators is called first, and\n// in turn calls the function that parses `[]` subscripts — that\n// way, it'll receive the node for `x[1]` already parsed, and wraps\n// *that* in the unary operator node.\n//\n// Acorn uses an [operator precedence parser][opp] to handle binary\n// operator precedence, because it is much more compact than using\n// the technique outlined above, which uses different, nesting\n// functions to specify precedence, for all of the ten binary\n// precedence levels that JavaScript defines.\n//\n// [opp]: http://en.wikipedia.org/wiki/Operator-precedence_parser\n\nimport {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\n\nconst pp = Parser.prototype\n\n// Check if property name clashes with already added.\n// Object/class getters and setters are not allowed to clash —\n// either with each other or with an init property — and in\n// strict mode, init properties are also not allowed to be repeated.\n\npp.checkPropClash = function(prop, propHash) {\n  if (this.options.ecmaVersion >= 6 && (prop.computed || prop.method || prop.shorthand))\n    return\n  let {key} = prop, name\n  switch (key.type) {\n  case \"Identifier\": name = key.name; break\n  case \"Literal\": name = String(key.value); break\n  default: return\n  }\n  let {kind} = prop\n  if (this.options.ecmaVersion >= 6) {\n    if (name === \"__proto__\" && kind === \"init\") {\n      if (propHash.proto) this.raise(key.start, \"Redefinition of __proto__ property\");\n      propHash.proto = true\n    }\n    return\n  }\n  name = \"$\" + name\n  let other = propHash[name]\n  if (other) {\n    let isGetSet = kind !== \"init\"\n    if ((this.strict || isGetSet) && other[kind] || !(isGetSet ^ other.init))\n      this.raise(key.start, \"Redefinition of property\")\n  } else {\n    other = propHash[name] = {\n      init: false,\n      get: false,\n      set: false\n    }\n  }\n  other[kind] = true\n}\n\n// ### Expression parsing\n\n// These nest, from the most general expression type at the top to\n// 'atomic', nondivisible expression types at the bottom. Most of\n// the functions will simply let the function(s) below them parse,\n// and, *if* the syntactic construct they handle is present, wrap\n// the AST node that the inner parser gave them in another node.\n\n// Parse a full expression. The optional arguments are used to\n// forbid the `in` operator (in for loops initalization expressions)\n// and provide reference for storing '=' operator inside shorthand\n// property assignment in contexts where both object expression\n// and object pattern might appear (so it's possible to raise\n// delayed syntax error at correct position).\n\npp.parseExpression = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeAssign(noIn, refDestructuringErrors)\n  if (this.type === tt.comma) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.expressions = [expr]\n    while (this.eat(tt.comma)) node.expressions.push(this.parseMaybeAssign(noIn, refDestructuringErrors))\n    return this.finishNode(node, \"SequenceExpression\")\n  }\n  return expr\n}\n\n// Parse an assignment expression. This includes applications of\n// operators like `+=`.\n\npp.parseMaybeAssign = function(noIn, refDestructuringErrors, afterLeftParse) {\n  if (this.type == tt._yield && this.inGenerator) return this.parseYield()\n\n  let validateDestructuring = false\n  if (!refDestructuringErrors) {\n    refDestructuringErrors = {shorthandAssign: 0, trailingComma: 0}\n    validateDestructuring = true\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  if (this.type == tt.parenL || this.type == tt.name)\n    this.potentialArrowAt = this.start\n  let left = this.parseMaybeConditional(noIn, refDestructuringErrors)\n  if (afterLeftParse) left = afterLeftParse.call(this, left, startPos, startLoc)\n  if (this.type.isAssign) {\n    if (validateDestructuring) this.checkPatternErrors(refDestructuringErrors, true)\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.left = this.type === tt.eq ? this.toAssignable(left) : left\n    refDestructuringErrors.shorthandAssign = 0 // reset because shorthand default was used correctly\n    this.checkLVal(left)\n    this.next()\n    node.right = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"AssignmentExpression\")\n  } else {\n    if (validateDestructuring) this.checkExpressionErrors(refDestructuringErrors, true)\n  }\n  return left\n}\n\n// Parse a ternary conditional (`?:`) operator.\n\npp.parseMaybeConditional = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprOps(noIn, refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  if (this.eat(tt.question)) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.test = expr\n    node.consequent = this.parseMaybeAssign()\n    this.expect(tt.colon)\n    node.alternate = this.parseMaybeAssign(noIn)\n    return this.finishNode(node, \"ConditionalExpression\")\n  }\n  return expr\n}\n\n// Start the precedence parser.\n\npp.parseExprOps = function(noIn, refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseMaybeUnary(refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  return this.parseExprOp(expr, startPos, startLoc, -1, noIn)\n}\n\n// Parse binary operators with the operator precedence parsing\n// algorithm. `left` is the left-hand side of the operator.\n// `minPrec` provides context that allows the function to stop and\n// defer further parser to one of its callers when it encounters an\n// operator that has a lower precedence than the set it is parsing.\n\npp.parseExprOp = function(left, leftStartPos, leftStartLoc, minPrec, noIn) {\n  let prec = this.type.binop\n  if (prec != null && (!noIn || this.type !== tt._in)) {\n    if (prec > minPrec) {\n      let node = this.startNodeAt(leftStartPos, leftStartLoc)\n      node.left = left\n      node.operator = this.value\n      let op = this.type\n      this.next()\n      let startPos = this.start, startLoc = this.startLoc\n      node.right = this.parseExprOp(this.parseMaybeUnary(), startPos, startLoc, prec, noIn)\n      this.finishNode(node, (op === tt.logicalOR || op === tt.logicalAND) ? \"LogicalExpression\" : \"BinaryExpression\")\n      return this.parseExprOp(node, leftStartPos, leftStartLoc, minPrec, noIn)\n    }\n  }\n  return left\n}\n\n// Parse unary operators, both prefix and postfix.\n\npp.parseMaybeUnary = function(refDestructuringErrors) {\n  if (this.type.prefix) {\n    let node = this.startNode(), update = this.type === tt.incDec\n    node.operator = this.value\n    node.prefix = true\n    this.next()\n    node.argument = this.parseMaybeUnary()\n    this.checkExpressionErrors(refDestructuringErrors, true)\n    if (update) this.checkLVal(node.argument)\n    else if (this.strict && node.operator === \"delete\" &&\n             node.argument.type === \"Identifier\")\n      this.raise(node.start, \"Deleting local variable in strict mode\")\n    return this.finishNode(node, update ? \"UpdateExpression\" : \"UnaryExpression\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprSubscripts(refDestructuringErrors)\n  if (this.checkExpressionErrors(refDestructuringErrors)) return expr\n  while (this.type.postfix && !this.canInsertSemicolon()) {\n    let node = this.startNodeAt(startPos, startLoc)\n    node.operator = this.value\n    node.prefix = false\n    node.argument = expr\n    this.checkLVal(expr)\n    this.next()\n    expr = this.finishNode(node, \"UpdateExpression\")\n  }\n  return expr\n}\n\n// Parse call, dot, and `[]`-subscript expressions.\n\npp.parseExprSubscripts = function(refDestructuringErrors) {\n  let startPos = this.start, startLoc = this.startLoc\n  let expr = this.parseExprAtom(refDestructuringErrors)\n  let skipArrowSubscripts = expr.type === \"ArrowFunctionExpression\" && this.input.slice(this.lastTokStart, this.lastTokEnd) !== \")\";\n  if (this.checkExpressionErrors(refDestructuringErrors) || skipArrowSubscripts) return expr\n  return this.parseSubscripts(expr, startPos, startLoc)\n}\n\npp.parseSubscripts = function(base, startPos, startLoc, noCalls) {\n  for (;;) {\n    if (this.eat(tt.dot)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseIdent(true)\n      node.computed = false\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (this.eat(tt.bracketL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.object = base\n      node.property = this.parseExpression()\n      node.computed = true\n      this.expect(tt.bracketR)\n      base = this.finishNode(node, \"MemberExpression\")\n    } else if (!noCalls && this.eat(tt.parenL)) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.callee = base\n      node.arguments = this.parseExprList(tt.parenR, false)\n      base = this.finishNode(node, \"CallExpression\")\n    } else if (this.type === tt.backQuote) {\n      let node = this.startNodeAt(startPos, startLoc)\n      node.tag = base\n      node.quasi = this.parseTemplate()\n      base = this.finishNode(node, \"TaggedTemplateExpression\")\n    } else {\n      return base\n    }\n  }\n}\n\n// Parse an atomic expression — either a single token that is an\n// expression, an expression started by a keyword like `function` or\n// `new`, or an expression wrapped in punctuation like `()`, `[]`,\n// or `{}`.\n\npp.parseExprAtom = function(refDestructuringErrors) {\n  let node, canBeArrow = this.potentialArrowAt == this.start\n  switch (this.type) {\n  case tt._super:\n    if (!this.inFunction)\n      this.raise(this.start, \"'super' outside of function or class\")\n  case tt._this:\n    let type = this.type === tt._this ? \"ThisExpression\" : \"Super\"\n    node = this.startNode()\n    this.next()\n    return this.finishNode(node, type)\n\n  case tt._yield:\n    if (this.inGenerator) this.unexpected()\n\n  case tt.name:\n    let startPos = this.start, startLoc = this.startLoc\n    let id = this.parseIdent(this.type !== tt.name)\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow))\n      return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), [id])\n    return id\n\n  case tt.regexp:\n    let value = this.value\n    node = this.parseLiteral(value.value)\n    node.regex = {pattern: value.pattern, flags: value.flags}\n    return node\n\n  case tt.num: case tt.string:\n    return this.parseLiteral(this.value)\n\n  case tt._null: case tt._true: case tt._false:\n    node = this.startNode()\n    node.value = this.type === tt._null ? null : this.type === tt._true\n    node.raw = this.type.keyword\n    this.next()\n    return this.finishNode(node, \"Literal\")\n\n  case tt.parenL:\n    return this.parseParenAndDistinguishExpression(canBeArrow)\n\n  case tt.bracketL:\n    node = this.startNode()\n    this.next()\n    // check whether this is array comprehension or regular array\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(node, false)\n    }\n    node.elements = this.parseExprList(tt.bracketR, true, true, refDestructuringErrors)\n    return this.finishNode(node, \"ArrayExpression\")\n\n  case tt.braceL:\n    return this.parseObj(false, refDestructuringErrors)\n\n  case tt._function:\n    node = this.startNode()\n    this.next()\n    return this.parseFunction(node, false)\n\n  case tt._class:\n    return this.parseClass(this.startNode(), false)\n\n  case tt._new:\n    return this.parseNew()\n\n  case tt.backQuote:\n    return this.parseTemplate()\n\n  default:\n    this.unexpected()\n  }\n}\n\npp.parseLiteral = function(value) {\n  let node = this.startNode()\n  node.value = value\n  node.raw = this.input.slice(this.start, this.end)\n  this.next()\n  return this.finishNode(node, \"Literal\")\n}\n\npp.parseParenExpression = function() {\n  this.expect(tt.parenL)\n  let val = this.parseExpression()\n  this.expect(tt.parenR)\n  return val\n}\n\npp.parseParenAndDistinguishExpression = function(canBeArrow) {\n  let startPos = this.start, startLoc = this.startLoc, val\n  if (this.options.ecmaVersion >= 6) {\n    this.next()\n\n    if (this.options.ecmaVersion >= 7 && this.type === tt._for) {\n      return this.parseComprehension(this.startNodeAt(startPos, startLoc), true)\n    }\n\n    let innerStartPos = this.start, innerStartLoc = this.startLoc\n    let exprList = [], first = true\n    let refDestructuringErrors = {shorthandAssign: 0, trailingComma: 0}, spreadStart, innerParenStart\n    while (this.type !== tt.parenR) {\n      first ? first = false : this.expect(tt.comma)\n      if (this.type === tt.ellipsis) {\n        spreadStart = this.start\n        exprList.push(this.parseParenItem(this.parseRest()))\n        break\n      } else {\n        if (this.type === tt.parenL && !innerParenStart) {\n          innerParenStart = this.start\n        }\n        exprList.push(this.parseMaybeAssign(false, refDestructuringErrors, this.parseParenItem))\n      }\n    }\n    let innerEndPos = this.start, innerEndLoc = this.startLoc\n    this.expect(tt.parenR)\n\n    if (canBeArrow && !this.canInsertSemicolon() && this.eat(tt.arrow)) {\n      this.checkPatternErrors(refDestructuringErrors, true)\n      if (innerParenStart) this.unexpected(innerParenStart)\n      return this.parseParenArrowList(startPos, startLoc, exprList)\n    }\n\n    if (!exprList.length) this.unexpected(this.lastTokStart)\n    if (spreadStart) this.unexpected(spreadStart)\n    this.checkExpressionErrors(refDestructuringErrors, true)\n\n    if (exprList.length > 1) {\n      val = this.startNodeAt(innerStartPos, innerStartLoc)\n      val.expressions = exprList\n      this.finishNodeAt(val, \"SequenceExpression\", innerEndPos, innerEndLoc)\n    } else {\n      val = exprList[0]\n    }\n  } else {\n    val = this.parseParenExpression()\n  }\n\n  if (this.options.preserveParens) {\n    let par = this.startNodeAt(startPos, startLoc)\n    par.expression = val\n    return this.finishNode(par, \"ParenthesizedExpression\")\n  } else {\n    return val\n  }\n}\n\npp.parseParenItem = function(item) {\n  return item\n}\n\npp.parseParenArrowList = function(startPos, startLoc, exprList) {\n  return this.parseArrowExpression(this.startNodeAt(startPos, startLoc), exprList)\n}\n\n// New's precedence is slightly tricky. It must allow its argument to\n// be a `[]` or dot subscript expression, but not a call — at least,\n// not without wrapping it in parentheses. Thus, it uses the noCalls\n// argument to parseSubscripts to prevent it from consuming the\n// argument list.\n\nconst empty = []\n\npp.parseNew = function() {\n  let node = this.startNode()\n  let meta = this.parseIdent(true)\n  if (this.options.ecmaVersion >= 6 && this.eat(tt.dot)) {\n    node.meta = meta\n    node.property = this.parseIdent(true)\n    if (node.property.name !== \"target\")\n      this.raise(node.property.start, \"The only valid meta property for new is new.target\")\n    if (!this.inFunction)\n      this.raise(node.start, \"new.target can only be used in functions\")\n    return this.finishNode(node, \"MetaProperty\")\n  }\n  let startPos = this.start, startLoc = this.startLoc\n  node.callee = this.parseSubscripts(this.parseExprAtom(), startPos, startLoc, true)\n  if (this.eat(tt.parenL)) node.arguments = this.parseExprList(tt.parenR, false)\n  else node.arguments = empty\n  return this.finishNode(node, \"NewExpression\")\n}\n\n// Parse template expression.\n\npp.parseTemplateElement = function() {\n  let elem = this.startNode()\n  elem.value = {\n    raw: this.input.slice(this.start, this.end).replace(/\\r\\n?/g, '\\n'),\n    cooked: this.value\n  }\n  this.next()\n  elem.tail = this.type === tt.backQuote\n  return this.finishNode(elem, \"TemplateElement\")\n}\n\npp.parseTemplate = function() {\n  let node = this.startNode()\n  this.next()\n  node.expressions = []\n  let curElt = this.parseTemplateElement()\n  node.quasis = [curElt]\n  while (!curElt.tail) {\n    this.expect(tt.dollarBraceL)\n    node.expressions.push(this.parseExpression())\n    this.expect(tt.braceR)\n    node.quasis.push(curElt = this.parseTemplateElement())\n  }\n  this.next()\n  return this.finishNode(node, \"TemplateLiteral\")\n}\n\n// Parse an object literal or binding pattern.\n\npp.parseObj = function(isPattern, refDestructuringErrors) {\n  let node = this.startNode(), first = true, propHash = {}\n  node.properties = []\n  this.next()\n  while (!this.eat(tt.braceR)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.afterTrailingComma(tt.braceR)) break\n    } else first = false\n\n    let prop = this.startNode(), isGenerator, startPos, startLoc\n    if (this.options.ecmaVersion >= 6) {\n      prop.method = false\n      prop.shorthand = false\n      if (isPattern || refDestructuringErrors) {\n        startPos = this.start\n        startLoc = this.startLoc\n      }\n      if (!isPattern)\n        isGenerator = this.eat(tt.star)\n    }\n    this.parsePropertyName(prop)\n    this.parsePropertyValue(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors)\n    this.checkPropClash(prop, propHash)\n    node.properties.push(this.finishNode(prop, \"Property\"))\n  }\n  return this.finishNode(node, isPattern ? \"ObjectPattern\" : \"ObjectExpression\")\n}\n\npp.parsePropertyValue = function(prop, isPattern, isGenerator, startPos, startLoc, refDestructuringErrors) {\n  if (this.eat(tt.colon)) {\n      prop.value = isPattern ? this.parseMaybeDefault(this.start, this.startLoc) : this.parseMaybeAssign(false, refDestructuringErrors)\n      prop.kind = \"init\"\n    } else if (this.options.ecmaVersion >= 6 && this.type === tt.parenL) {\n      if (isPattern) this.unexpected()\n      prop.kind = \"init\"\n      prop.method = true\n      prop.value = this.parseMethod(isGenerator)\n    } else if (this.options.ecmaVersion >= 5 && !prop.computed && prop.key.type === \"Identifier\" &&\n               (prop.key.name === \"get\" || prop.key.name === \"set\") &&\n               (this.type != tt.comma && this.type != tt.braceR)) {\n      if (isGenerator || isPattern) this.unexpected()\n      prop.kind = prop.key.name\n      this.parsePropertyName(prop)\n      prop.value = this.parseMethod(false)\n      let paramCount = prop.kind === \"get\" ? 0 : 1\n      if (prop.value.params.length !== paramCount) {\n        let start = prop.value.start\n        if (prop.kind === \"get\")\n          this.raise(start, \"getter should have no params\");\n        else\n          this.raise(start, \"setter should have exactly one param\")\n      }\n      if (prop.kind === \"set\" && prop.value.params[0].type === \"RestElement\")\n        this.raise(prop.value.params[0].start, \"Setter cannot use rest params\")\n    } else if (this.options.ecmaVersion >= 6 && !prop.computed && prop.key.type === \"Identifier\") {\n      prop.kind = \"init\"\n      if (isPattern) {\n        if (this.keywords.test(prop.key.name) ||\n            (this.strict ? this.reservedWordsStrictBind : this.reservedWords).test(prop.key.name))\n          this.raise(prop.key.start, \"Binding \" + prop.key.name)\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else if (this.type === tt.eq && refDestructuringErrors) {\n        if (!refDestructuringErrors.shorthandAssign)\n          refDestructuringErrors.shorthandAssign = this.start\n        prop.value = this.parseMaybeDefault(startPos, startLoc, prop.key)\n      } else {\n        prop.value = prop.key\n      }\n      prop.shorthand = true\n    } else this.unexpected()\n}\n\npp.parsePropertyName = function(prop) {\n  if (this.options.ecmaVersion >= 6) {\n    if (this.eat(tt.bracketL)) {\n      prop.computed = true\n      prop.key = this.parseMaybeAssign()\n      this.expect(tt.bracketR)\n      return prop.key\n    } else {\n      prop.computed = false\n    }\n  }\n  return prop.key = (this.type === tt.num || this.type === tt.string) ? this.parseExprAtom() : this.parseIdent(true)\n}\n\n// Initialize empty function node.\n\npp.initFunction = function(node) {\n  node.id = null\n  if (this.options.ecmaVersion >= 6) {\n    node.generator = false\n    node.expression = false\n  }\n}\n\n// Parse object or class method.\n\npp.parseMethod = function(isGenerator) {\n  let node = this.startNode()\n  this.initFunction(node)\n  this.expect(tt.parenL)\n  node.params = this.parseBindingList(tt.parenR, false, false)\n  if (this.options.ecmaVersion >= 6)\n    node.generator = isGenerator\n  this.parseFunctionBody(node, false)\n  return this.finishNode(node, \"FunctionExpression\")\n}\n\n// Parse arrow function expression with given parameters.\n\npp.parseArrowExpression = function(node, params) {\n  this.initFunction(node)\n  node.params = this.toAssignableList(params, true)\n  this.parseFunctionBody(node, true)\n  return this.finishNode(node, \"ArrowFunctionExpression\")\n}\n\n// Parse function body and check parameters.\n\npp.parseFunctionBody = function(node, isArrowFunction) {\n  let isExpression = isArrowFunction && this.type !== tt.braceL\n\n  if (isExpression) {\n    node.body = this.parseMaybeAssign()\n    node.expression = true\n  } else {\n    // Start a new scope with regard to labels and the `inFunction`\n    // flag (restore them to their old value afterwards).\n    let oldInFunc = this.inFunction, oldInGen = this.inGenerator, oldLabels = this.labels\n    this.inFunction = true; this.inGenerator = node.generator; this.labels = []\n    node.body = this.parseBlock(true)\n    node.expression = false\n    this.inFunction = oldInFunc; this.inGenerator = oldInGen; this.labels = oldLabels\n  }\n\n  // If this is a strict mode function, verify that argument names\n  // are not repeated, and it does not try to bind the words `eval`\n  // or `arguments`.\n  if (this.strict || !isExpression && node.body.body.length && this.isUseStrict(node.body.body[0])) {\n    let oldStrict = this.strict\n    this.strict = true\n    if (node.id)\n      this.checkLVal(node.id, true)\n    this.checkParams(node);\n    this.strict = oldStrict\n  } else if (isArrowFunction) {\n    this.checkParams(node);\n  }\n}\n\n// Checks function params for various disallowed patterns such as using \"eval\"\n// or \"arguments\" and duplicate parameters.\n\npp.checkParams = function(node) {\n    let nameHash = {};\n    for (let i = 0; i < node.params.length; i++)\n      this.checkLVal(node.params[i], true, nameHash)\n};\n\n// Parses a comma-separated list of expressions, and returns them as\n// an array. `close` is the token type that ends the list, and\n// `allowEmpty` can be turned on to allow subsequent commas with\n// nothing in between them to be parsed as `null` (which is needed\n// for array literals).\n\npp.parseExprList = function(close, allowTrailingComma, allowEmpty, refDestructuringErrors) {\n  let elts = [], first = true\n  while (!this.eat(close)) {\n    if (!first) {\n      this.expect(tt.comma)\n      if (this.type === close && refDestructuringErrors && !refDestructuringErrors.trailingComma) {\n        refDestructuringErrors.trailingComma = this.lastTokStart\n      }\n      if (allowTrailingComma && this.afterTrailingComma(close)) break\n    } else first = false\n\n    let elt\n    if (allowEmpty && this.type === tt.comma)\n      elt = null\n    else if (this.type === tt.ellipsis)\n      elt = this.parseSpread(refDestructuringErrors)\n    else\n      elt = this.parseMaybeAssign(false, refDestructuringErrors)\n    elts.push(elt)\n  }\n  return elts\n}\n\n// Parse the next token as an identifier. If `liberal` is true (used\n// when parsing properties), it will also convert keywords into\n// identifiers.\n\npp.parseIdent = function(liberal) {\n  let node = this.startNode()\n  if (liberal && this.options.allowReserved == \"never\") liberal = false\n  if (this.type === tt.name) {\n    if (!liberal && (this.strict ? this.reservedWordsStrict : this.reservedWords).test(this.value) &&\n        (this.options.ecmaVersion >= 6 ||\n         this.input.slice(this.start, this.end).indexOf(\"\\\\\") == -1))\n      this.raise(this.start, \"The keyword '\" + this.value + \"' is reserved\")\n    node.name = this.value\n  } else if (liberal && this.type.keyword) {\n    node.name = this.type.keyword\n  } else {\n    this.unexpected()\n  }\n  this.next()\n  return this.finishNode(node, \"Identifier\")\n}\n\n// Parses yield expression inside generator.\n\npp.parseYield = function() {\n  let node = this.startNode()\n  this.next()\n  if (this.type == tt.semi || this.canInsertSemicolon() || (this.type != tt.star && !this.type.startsExpr)) {\n    node.delegate = false\n    node.argument = null\n  } else {\n    node.delegate = this.eat(tt.star)\n    node.argument = this.parseMaybeAssign()\n  }\n  return this.finishNode(node, \"YieldExpression\")\n}\n\n// Parses array and generator comprehensions.\n\npp.parseComprehension = function(node, isGenerator) {\n  node.blocks = []\n  while (this.type === tt._for) {\n    let block = this.startNode()\n    this.next()\n    this.expect(tt.parenL)\n    block.left = this.parseBindingAtom()\n    this.checkLVal(block.left, true)\n    this.expectContextual(\"of\")\n    block.right = this.parseExpression()\n    this.expect(tt.parenR)\n    node.blocks.push(this.finishNode(block, \"ComprehensionBlock\"))\n  }\n  node.filter = this.eat(tt._if) ? this.parseParenExpression() : null\n  node.body = this.parseExpression()\n  this.expect(isGenerator ? tt.parenR : tt.bracketR)\n  node.generator = isGenerator\n  return this.finishNode(node, \"ComprehensionExpression\")\n}\n"]}