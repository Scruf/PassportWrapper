{"version":3,"sources":["parseutil.js"],"names":[],"mappings":"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","file":"parseutil-compiled.js","sourcesContent":["import {types as tt} from \"./tokentype\"\nimport {Parser} from \"./state\"\nimport {lineBreak} from \"./whitespace\"\n\nconst pp = Parser.prototype\n\n// ## Parser utilities\n\n// Test whether a statement node is the string literal `\"use strict\"`.\n\npp.isUseStrict = function(stmt) {\n  return this.options.ecmaVersion >= 5 && stmt.type === \"ExpressionStatement\" &&\n    stmt.expression.type === \"Literal\" &&\n    stmt.expression.raw.slice(1, -1) === \"use strict\"\n}\n\n// Predicate that tests whether the next token is of the given\n// type, and if yes, consumes it as a side effect.\n\npp.eat = function(type) {\n  if (this.type === type) {\n    this.next()\n    return true\n  } else {\n    return false\n  }\n}\n\n// Tests whether parsed token is a contextual keyword.\n\npp.isContextual = function(name) {\n  return this.type === tt.name && this.value === name\n}\n\n// Consumes contextual keyword if possible.\n\npp.eatContextual = function(name) {\n  return this.value === name && this.eat(tt.name)\n}\n\n// Asserts that following token is given contextual keyword.\n\npp.expectContextual = function(name) {\n  if (!this.eatContextual(name)) this.unexpected()\n}\n\n// Test whether a semicolon can be inserted at the current position.\n\npp.canInsertSemicolon = function() {\n  return this.type === tt.eof ||\n    this.type === tt.braceR ||\n    lineBreak.test(this.input.slice(this.lastTokEnd, this.start))\n}\n\npp.insertSemicolon = function() {\n  if (this.canInsertSemicolon()) {\n    if (this.options.onInsertedSemicolon)\n      this.options.onInsertedSemicolon(this.lastTokEnd, this.lastTokEndLoc)\n    return true\n  }\n}\n\n// Consume a semicolon, or, failing that, see if we are allowed to\n// pretend that there is a semicolon at this position.\n\npp.semicolon = function() {\n  if (!this.eat(tt.semi) && !this.insertSemicolon()) this.unexpected()\n}\n\npp.afterTrailingComma = function(tokType) {\n  if (this.type == tokType) {\n    if (this.options.onTrailingComma)\n      this.options.onTrailingComma(this.lastTokStart, this.lastTokStartLoc)\n    this.next()\n    return true\n  }\n}\n\n// Expect a token of a given type. If found, consume it, otherwise,\n// raise an unexpected token error.\n\npp.expect = function(type) {\n  this.eat(type) || this.unexpected()\n}\n\n// Raise an unexpected token error.\n\npp.unexpected = function(pos) {\n  this.raise(pos != null ? pos : this.start, \"Unexpected token\")\n}\n\npp.checkPatternErrors = function(refDestructuringErrors, andThrow) {\n  let pos = refDestructuringErrors && refDestructuringErrors.trailingComma\n  if (!andThrow) return !!pos\n  if (pos) this.raise(pos, \"Trailing comma is not permitted in destructuring patterns\")\n}\n\npp.checkExpressionErrors = function(refDestructuringErrors, andThrow) {\n  let pos = refDestructuringErrors && refDestructuringErrors.shorthandAssign\n  if (!andThrow) return !!pos\n  if (pos) this.raise(pos, \"Shorthand property assignments are valid only in destructuring patterns\")\n}\n"]}