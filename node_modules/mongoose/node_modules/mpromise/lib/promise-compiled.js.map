{"version":3,"sources":["promise.js"],"names":[],"mappings":"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","file":"promise-compiled.js","sourcesContent":["'use strict';\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nfunction toArray(arr, start, end) {\n  return Array.prototype.slice.call(arr, start, end)\n}\nfunction strongUnshift(x, arrLike) {\n  var arr = toArray(arrLike);\n  arr.unshift(x);\n  return arr;\n}\n\n\n/**\n * MPromise constructor.\n *\n * _NOTE: The success and failure event names can be overridden by setting `Promise.SUCCESS` and `Promise.FAILURE` respectively._\n *\n * @param {Function} back a function that accepts `fn(err, ...){}` as signature\n * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter\n * @event `reject`: Emits when the promise is rejected (event name may be overridden)\n * @event `fulfill`: Emits when the promise is fulfilled (event name may be overridden)\n * @api public\n */\nfunction Promise(back) {\n  this.emitter = new EventEmitter();\n  this.emitted = {};\n  this.ended = false;\n  if ('function' == typeof back) {\n    this.ended = true;\n    this.onResolve(back);\n  }\n}\n\n\n/*\n * Module exports.\n */\nmodule.exports = Promise;\n\n\n/*!\n * event names\n */\nPromise.SUCCESS = 'fulfill';\nPromise.FAILURE = 'reject';\n\n\n/**\n * Adds `listener` to the `event`.\n *\n * If `event` is either the success or failure event and the event has already been emitted, the`listener` is called immediately and passed the results of the original emitted event.\n *\n * @param {String} event\n * @param {Function} callback\n * @return {MPromise} this\n * @api private\n */\nPromise.prototype.on = function (event, callback) {\n  if (this.emitted[event])\n    callback.apply(undefined, this.emitted[event]);\n  else\n    this.emitter.on(event, callback);\n\n  return this;\n};\n\n\n/**\n * Keeps track of emitted events to run them on `on`.\n *\n * @api private\n */\nPromise.prototype.safeEmit = function (event) {\n  // ensures a promise can't be fulfill() or reject() more than once\n  if (event == Promise.SUCCESS || event == Promise.FAILURE) {\n    if (this.emitted[Promise.SUCCESS] || this.emitted[Promise.FAILURE]) {\n      return this;\n    }\n    this.emitted[event] = toArray(arguments, 1);\n  }\n\n  this.emitter.emit.apply(this.emitter, arguments);\n  return this;\n};\n\n\n/**\n * @api private\n */\nPromise.prototype.hasRejectListeners = function () {\n  return EventEmitter.listenerCount(this.emitter, Promise.FAILURE) > 0;\n};\n\n\n/**\n * Fulfills this promise with passed arguments.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n */\nPromise.prototype.fulfill = function () {\n  return this.safeEmit.apply(this, strongUnshift(Promise.SUCCESS, arguments));\n};\n\n\n/**\n * Rejects this promise with `reason`.\n *\n * If this promise has already been fulfilled or rejected, no action is taken.\n *\n * @api public\n * @param {Object|String} reason\n * @return {MPromise} this\n */\nPromise.prototype.reject = function (reason) {\n  if (this.ended && !this.hasRejectListeners())\n    throw reason;\n  return this.safeEmit(Promise.FAILURE, reason);\n};\n\n\n/**\n * Resolves this promise to a rejected state if `err` is passed or\n * fulfilled state if no `err` is passed.\n *\n * @param {Error} [err] error or null\n * @param {Object} [val] value to fulfill the promise with\n * @api public\n */\nPromise.prototype.resolve = function (err, val) {\n  if (err) return this.reject(err);\n  return this.fulfill(val);\n};\n\n\n/**\n * Adds a listener to the SUCCESS event.\n *\n * @return {MPromise} this\n * @api public\n */\nPromise.prototype.onFulfill = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.SUCCESS, fn);\n};\n\n\n/**\n * Adds a listener to the FAILURE event.\n *\n * @return {MPromise} this\n * @api public\n */\nPromise.prototype.onReject = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  return this.on(Promise.FAILURE, fn);\n};\n\n\n/**\n * Adds a single function as a listener to both SUCCESS and FAILURE.\n *\n * It will be executed with traditional node.js argument position:\n * function (err, args...) {}\n *\n * Also marks the promise as `end`ed, since it's the common use-case, and yet has no\n * side effects unless `fn` is undefined or null.\n *\n * @param {Function} fn\n * @return {MPromise} this\n */\nPromise.prototype.onResolve = function (fn) {\n  if (!fn) return this;\n  if ('function' != typeof fn) throw new TypeError(\"fn should be a function\");\n  this.on(Promise.FAILURE, function (err) { fn.call(this, err); });\n  this.on(Promise.SUCCESS, function () { fn.apply(this, strongUnshift(null, arguments)); });\n  return this;\n};\n\n\n/**\n * Creates a new promise and returns it. If `onFulfill` or\n * `onReject` are passed, they are added as SUCCESS/ERROR callbacks\n * to this promise after the next tick.\n *\n * Conforms to [promises/A+](https://github.com/promises-aplus/promises-spec) specification. Read for more detail how to use this method.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function (arg) {\n *       return arg + 1;\n *     }).then(function (arg) {\n *       throw new Error(arg + ' is an error!');\n *     }).then(null, function (err) {\n *       assert.ok(err instanceof Error);\n *       assert.equal('2 is an error', err.message);\n *     });\n *     p.complete(1);\n *\n * @see promises-A+ https://github.com/promises-aplus/promises-spec\n * @param {Function} onFulfill\n * @param {Function} [onReject]\n * @return {MPromise} newPromise\n */\nPromise.prototype.then = function (onFulfill, onReject) {\n  var newPromise = new Promise;\n\n  if ('function' == typeof onFulfill) {\n    this.onFulfill(handler(newPromise, onFulfill));\n  } else {\n    this.onFulfill(newPromise.fulfill.bind(newPromise));\n  }\n\n  if ('function' == typeof onReject) {\n    this.onReject(handler(newPromise, onReject));\n  } else {\n    this.onReject(newPromise.reject.bind(newPromise));\n  }\n\n  return newPromise;\n};\n\n\nfunction handler(promise, fn) {\n  function newTickHandler() {\n    var pDomain = promise.emitter.domain;\n    if (pDomain && pDomain !== process.domain) pDomain.enter();\n    try {\n      var x = fn.apply(undefined, boundHandler.args);\n    } catch (err) {\n      promise.reject(err);\n      return;\n    }\n    resolve(promise, x);\n  }\n  function boundHandler() {\n    boundHandler.args = arguments;\n    process.nextTick(newTickHandler);\n  }\n  return boundHandler;\n}\n\n\nfunction resolve(promise, x) {\n  function fulfillOnce() {\n    if (done++) return;\n    resolve.apply(undefined, strongUnshift(promise, arguments));\n  }\n  function rejectOnce(reason) {\n    if (done++) return;\n    promise.reject(reason);\n  }\n\n  if (promise === x) {\n    promise.reject(new TypeError(\"promise and x are the same\"));\n    return;\n  }\n  var rest = toArray(arguments, 1);\n  var type = typeof x;\n  if ('undefined' == type || null == x || !('object' == type || 'function' == type)) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  try {\n    var theThen = x.then;\n  } catch (err) {\n    promise.reject(err);\n    return;\n  }\n\n  if ('function' != typeof theThen) {\n    promise.fulfill.apply(promise, rest);\n    return;\n  }\n\n  var done = 0;\n  try {\n    var ret = theThen.call(x, fulfillOnce, rejectOnce);\n    return ret;\n  } catch (err) {\n    if (done++) return;\n    promise.reject(err);\n  }\n}\n\n\n/**\n * Signifies that this promise was the last in a chain of `then()s`: if a handler passed to the call to `then` which produced this promise throws, the exception will go uncaught.\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {Function} [onReject]\n * @return {MPromise} this\n */\nPromise.prototype.end = Promise.prototype['catch'] = function (onReject) {\n  if (!onReject && !this.hasRejectListeners())\n    onReject = function idRejector(e) { throw e; };\n  this.onReject(onReject);\n  this.ended = true;\n  return this;\n};\n\n\n/**\n * A debug utility function that adds handlers to a promise that will log some output to the `console`\n *\n * ####Example:\n *\n *     var p = new Promise;\n *     p.then(function(){ throw new Error('shucks') });\n *     setTimeout(function () {\n *       p.fulfill();\n *       // error was caught and swallowed by the promise returned from\n *       // p.then(). we either have to always register handlers on\n *       // the returned promises or we can do the following...\n *     }, 10);\n *\n *     // this time we use .end() which prevents catching thrown errors\n *     var p = new Promise;\n *     var p2 = p.then(function(){ throw new Error('shucks') }).end(); // <--\n *     setTimeout(function () {\n *       p.fulfill(); // throws \"shucks\"\n *     }, 10);\n *\n * @api public\n * @param {MPromise} p\n * @param {String} name\n * @return {MPromise} this\n */\nPromise.trace = function (p, name) {\n  p.then(\n    function () {\n      console.log(\"%s fulfill %j\", name, toArray(arguments));\n    },\n    function () {\n      console.log(\"%s reject %j\", name, toArray(arguments));\n    }\n  )\n};\n\n\nPromise.prototype.chain = function (p2) {\n  var p1 = this;\n  p1.onFulfill(p2.fulfill.bind(p2));\n  p1.onReject(p2.reject.bind(p2));\n  return p2;\n};\n\n\nPromise.prototype.all = function (promiseOfArr) {\n  var pRet = new Promise;\n  this.then(promiseOfArr).then(\n    function (promiseArr) {\n      var count = 0;\n      var ret = [];\n      var errSentinel;\n      if (!promiseArr.length) pRet.resolve();\n      promiseArr.forEach(function (promise, index) {\n        if (errSentinel) return;\n        count++;\n        promise.then(\n          function (val) {\n            if (errSentinel) return;\n            ret[index] = val;\n            --count;\n            if (count == 0) pRet.fulfill(ret);\n          },\n          function (err) {\n            if (errSentinel) return;\n            errSentinel = err;\n            pRet.reject(err);\n          }\n        );\n      });\n      return pRet;\n    }\n    , pRet.reject.bind(pRet)\n  );\n  return pRet;\n};\n\n\nPromise.hook = function (arr) {\n  var p1 = new Promise;\n  var pFinal = new Promise;\n  var signalP = function () {\n    --count;\n    if (count == 0)\n      pFinal.fulfill();\n    return pFinal;\n  };\n  var count = 1;\n  var ps = p1;\n  arr.forEach(function (hook) {\n    ps = ps.then(\n      function () {\n        var p = new Promise;\n        count++;\n        hook(p.resolve.bind(p), signalP);\n        return p;\n      }\n    )\n  });\n  ps = ps.then(signalP);\n  p1.resolve();\n  return ps;\n};\n\n\n/* This is for the A+ tests, but it's very useful as well */\nPromise.fulfilled = function fulfilled() { var p = new Promise; p.fulfill.apply(p, arguments); return p; };\nPromise.rejected = function rejected(reason) { return new Promise().reject(reason); };\nPromise.deferred = function deferred() {\n  var p = new Promise;\n  return {\n    promise: p,\n    reject: p.reject.bind(p),\n    resolve: p.fulfill.bind(p),\n    callback: p.resolve.bind(p)\n  }\n};\n/* End A+ tests adapter bit */\n"]}