{"version":3,"sources":["connection.js"],"names":[],"mappings":"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","file":"connection-compiled.js","sourcesContent":["\"use strict\";\n\nvar inherits = require('util').inherits\n  , EventEmitter = require('events').EventEmitter\n  , net = require('net')\n  , tls = require('tls')\n  , f = require('util').format\n  , crypto = require('crypto')\n  , getSingleProperty = require('./utils').getSingleProperty\n  , debugOptions = require('./utils').debugOptions\n  , Response = require('./commands').Response\n  , MongoError = require('../error')\n  , Logger = require('./logger');\n\nvar _id = 0;\nvar debugFields = ['host', 'port', 'size', 'keepAlive', 'keepAliveInitialDelay', 'noDelay'\n  , 'connectionTimeout', 'socketTimeout', 'singleBufferSerializtion', 'ssl', 'ca', 'cert'\n  , 'rejectUnauthorized', 'promoteLongs', 'checkServerIdentity'];\n\n/**\n * Creates a new Connection instance\n * @class\n * @param {string} options.host The server host\n * @param {number} options.port The server port\n * @param {number} [options.size=5] Server connection pool size\n * @param {boolean} [options.keepAlive=true] TCP Connection keep alive enabled\n * @param {number} [options.keepAliveInitialDelay=0] Initial delay before TCP keep alive enabled\n * @param {boolean} [options.noDelay=true] TCP Connection no delay\n * @param {number} [options.connectionTimeout=0] TCP Connection timeout setting\n * @param {number} [options.socketTimeout=0] TCP Socket timeout setting\n * @param {boolean} [options.singleBufferSerializtion=true] Serialize into single buffer, trade of peak memory for serialization speed\n * @param {boolean} [options.ssl=false] Use SSL for connection\n * @param {boolean|function} [options.checkServerIdentity=true] Ensure we check server identify during SSL, set to false to disable checking. Only works for Node 0.12.x or higher. You can pass in a boolean or your own checkServerIdentity override function.\n * @param {Buffer} [options.ca] SSL Certificate store binary buffer\n * @param {Buffer} [options.cert] SSL Certificate binary buffer\n * @param {Buffer} [options.key] SSL Key file binary buffer\n * @param {string} [options.passphrase] SSL Certificate pass phrase\n * @param {boolean} [options.rejectUnauthorized=true] Reject unauthorized server certificates\n * @param {boolean} [options.promoteLongs=true] Convert Long values from the db into Numbers if they fit into 53 bits\n * @fires Connection#connect\n * @fires Connection#close\n * @fires Connection#error\n * @fires Connection#timeout\n * @fires Connection#parseError\n * @return {Connection} A cursor instance\n */\nvar Connection = function(options) {\n  // Add event listener\n  EventEmitter.call(this);\n  // Set empty if no options passed\n  this.options = options || {};\n  // Identification information\n  this.id = _id++;\n  // Logger instance\n  this.logger = Logger('Connection', options);\n  // No bson parser passed in\n  if(!options.bson) throw new Error(\"must pass in valid bson parser\");\n  // Get bson parser\n  this.bson = options.bson;\n  // Grouping tag used for debugging purposes\n  this.tag = options.tag;\n  // Message handler\n  this.messageHandler = options.messageHandler;\n\n  // Max BSON message size\n  this.maxBsonMessageSize = options.maxBsonMessageSize || (1024 * 1024 * 16 * 4);\n  // Debug information\n  if(this.logger.isDebug()) this.logger.debug(f('creating connection %s with options [%s]', this.id, JSON.stringify(debugOptions(debugFields, options))));\n\n  // Default options\n  this.port = options.port || 27017;\n  this.host = options.host || 'localhost';\n  this.keepAlive = typeof options.keepAlive == 'boolean' ? options.keepAlive : true;\n  this.keepAliveInitialDelay = options.keepAliveInitialDelay || 0;\n  this.noDelay = typeof options.noDelay == 'boolean' ? options.noDelay : true;\n  this.connectionTimeout = options.connectionTimeout || 0;\n  this.socketTimeout = options.socketTimeout || 0;\n\n  // If connection was destroyed\n  this.destroyed = false;\n\n  // Check if we have a domain socket\n  this.domainSocket = this.host.indexOf('\\/') != -1;\n\n  // Serialize commands using function\n  this.singleBufferSerializtion = typeof options.singleBufferSerializtion == 'boolean' ? options.singleBufferSerializtion : true;\n  this.serializationFunction = this.singleBufferSerializtion ? 'toBinUnified' : 'toBin';\n\n  // SSL options\n  this.ca = options.ca || null;\n  this.cert = options.cert || null;\n  this.key = options.key || null;\n  this.passphrase = options.passphrase || null;\n  this.ssl = typeof options.ssl == 'boolean' ? options.ssl : false;\n  this.rejectUnauthorized = typeof options.rejectUnauthorized == 'boolean' ? options.rejectUnauthorized : true;\n  this.checkServerIdentity = typeof options.checkServerIdentity == 'boolean'\n    || typeof options.checkServerIdentity == 'function' ? options.checkServerIdentity : true;\n\n  // If ssl not enabled\n  if(!this.ssl) this.rejectUnauthorized = false;\n\n  // Response options\n  this.responseOptions = {\n    promoteLongs: typeof options.promoteLongs == 'boolean' ?  options.promoteLongs : true\n  }\n\n  // Flushing\n  this.flushing = false;\n  this.queue = [];\n\n  // Internal state\n  this.connection = null;\n  this.writeStream = null;\n\n  // Create hash method\n  var hash = crypto.createHash('sha1');\n  hash.update(f('%s:%s', this.host, this.port));\n\n  // Create a hash name\n  this.hashedName = hash.digest('hex');\n}\n\ninherits(Connection, EventEmitter);\n\nObject.defineProperty(Connection.prototype, 'socketTimeoutMS', {\n    enumerable:true,\n    set: function(value) {\n      if(typeof value != 'number') throw new Error(\"socketTimeoutMS requires a boolean\");\n      // Set the socket timeout\n      this.socketTimeout = value;\n      // Set the socket timeout on the socket\n      this.connection.setTimeout(value);\n    }\n  , get: function() { return this.socketTimeout; }\n});\n\n//\n// Connection handlers\nvar errorHandler = function(self) {\n  return function(err) {\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] errored out with [%s]', self.id, self.host, self.port, JSON.stringify(err)));\n    // Emit the error\n    if(self.listeners('error').length > 0) self.emit(\"error\", MongoError.create(err), self);\n  }\n}\n\nvar timeoutHandler = function(self) {\n  return function() {\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s for [%s:%s] timed out', self.id, self.host, self.port));\n    // Emit timeout error\n    self.emit(\"timeout\"\n      , MongoError.create(f(\"connection %s to %s:%s timed out\", self.id, self.host, self.port))\n      , self);\n  }\n}\n\nvar closeHandler = function(self) {\n  return function(hadError) {\n    // Debug information\n    if(self.logger.isDebug()) self.logger.debug(f('connection %s with for [%s:%s] closed', self.id, self.host, self.port));\n    // Emit close event\n    if(!hadError) {\n      self.emit(\"close\"\n        , MongoError.create(f(\"connection %s to %s:%s closed\", self.id, self.host, self.port))\n        , self);\n    }\n  }\n}\n\nvar dataHandler = function(self) {\n  return function(data) {\n    // Parse until we are done with the data\n    while(data.length > 0) {\n      // If we still have bytes to read on the current message\n      if(self.bytesRead > 0 && self.sizeOfMessage > 0) {\n        // Calculate the amount of remaining bytes\n        var remainingBytesToRead = self.sizeOfMessage - self.bytesRead;\n        // Check if the current chunk contains the rest of the message\n        if(remainingBytesToRead > data.length) {\n          // Copy the new data into the exiting buffer (should have been allocated when we know the message size)\n          data.copy(self.buffer, self.bytesRead);\n          // Adjust the number of bytes read so it point to the correct index in the buffer\n          self.bytesRead = self.bytesRead + data.length;\n\n          // Reset state of buffer\n          data = new Buffer(0);\n        } else {\n          // Copy the missing part of the data into our current buffer\n          data.copy(self.buffer, self.bytesRead, 0, remainingBytesToRead);\n          // Slice the overflow into a new buffer that we will then re-parse\n          data = data.slice(remainingBytesToRead);\n\n          // Emit current complete message\n          try {\n            var emitBuffer = self.buffer;\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n            // Emit the buffer\n            self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);\n          } catch(err) {\n            var errorObject = {err:\"socketHandler\", trace:err, bin:self.buffer, parseState:{\n              sizeOfMessage:self.sizeOfMessage,\n              bytesRead:self.bytesRead,\n              stubBuffer:self.stubBuffer}};\n            // We got a parse Error fire it off then keep going\n            self.emit(\"parseError\", errorObject, self);\n          }\n        }\n      } else {\n        // Stub buffer is kept in case we don't get enough bytes to determine the\n        // size of the message (< 4 bytes)\n        if(self.stubBuffer != null && self.stubBuffer.length > 0) {\n          // If we have enough bytes to determine the message size let's do it\n          if(self.stubBuffer.length + data.length > 4) {\n            // Prepad the data\n            var newData = new Buffer(self.stubBuffer.length + data.length);\n            self.stubBuffer.copy(newData, 0);\n            data.copy(newData, self.stubBuffer.length);\n            // Reassign for parsing\n            data = newData;\n\n            // Reset state of buffer\n            self.buffer = null;\n            self.sizeOfMessage = 0;\n            self.bytesRead = 0;\n            self.stubBuffer = null;\n\n          } else {\n\n            // Add the the bytes to the stub buffer\n            var newStubBuffer = new Buffer(self.stubBuffer.length + data.length);\n            // Copy existing stub buffer\n            self.stubBuffer.copy(newStubBuffer, 0);\n            // Copy missing part of the data\n            data.copy(newStubBuffer, self.stubBuffer.length);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        } else {\n          if(data.length > 4) {\n            // Retrieve the message size\n            // var sizeOfMessage = data.readUInt32LE(0);\n            var sizeOfMessage = data[0] | data[1] << 8 | data[2] << 16 | data[3] << 24;\n            // If we have a negative sizeOfMessage emit error and return\n            if(sizeOfMessage < 0 || sizeOfMessage > self.maxBsonMessageSize) {\n              var errorObject = {err:\"socketHandler\", trace:'', bin:self.buffer, parseState:{\n                sizeOfMessage: sizeOfMessage,\n                bytesRead: self.bytesRead,\n                stubBuffer: self.stubBuffer}};\n              // We got a parse Error fire it off then keep going\n              self.emit(\"parseError\", errorObject, self);\n              return;\n            }\n\n            // Ensure that the size of message is larger than 0 and less than the max allowed\n            if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage > data.length) {\n              self.buffer = new Buffer(sizeOfMessage);\n              // Copy all the data into the buffer\n              data.copy(self.buffer, 0);\n              // Update bytes read\n              self.bytesRead = data.length;\n              // Update sizeOfMessage\n              self.sizeOfMessage = sizeOfMessage;\n              // Ensure stub buffer is null\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n\n            } else if(sizeOfMessage > 4 && sizeOfMessage < self.maxBsonMessageSize && sizeOfMessage == data.length) {\n              try {\n                var emitBuffer = data;\n                // Reset state of buffer\n                self.buffer = null;\n                self.sizeOfMessage = 0;\n                self.bytesRead = 0;\n                self.stubBuffer = null;\n                // Exit parsing loop\n                data = new Buffer(0);\n                // Emit the message\n                self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);\n              } catch (err) {\n                var errorObject = {err:\"socketHandler\", trace:err, bin:self.buffer, parseState:{\n                  sizeOfMessage:self.sizeOfMessage,\n                  bytesRead:self.bytesRead,\n                  stubBuffer:self.stubBuffer}};\n                // We got a parse Error fire it off then keep going\n                self.emit(\"parseError\", errorObject, self);\n              }\n            } else if(sizeOfMessage <= 4 || sizeOfMessage > self.maxBsonMessageSize) {\n              var errorObject = {err:\"socketHandler\", trace:null, bin:data, parseState:{\n                sizeOfMessage:sizeOfMessage,\n                bytesRead:0,\n                buffer:null,\n                stubBuffer:null}};\n              // We got a parse Error fire it off then keep going\n              self.emit(\"parseError\", errorObject, self);\n\n              // Clear out the state of the parser\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Exit parsing loop\n              data = new Buffer(0);\n            } else {\n              var emitBuffer = data.slice(0, sizeOfMessage);\n              // Reset state of buffer\n              self.buffer = null;\n              self.sizeOfMessage = 0;\n              self.bytesRead = 0;\n              self.stubBuffer = null;\n              // Copy rest of message\n              data = data.slice(sizeOfMessage);\n              // Emit the message\n              self.messageHandler(new Response(self, self.bson, emitBuffer, self.responseOptions), self);\n            }\n          } else {\n            // Create a buffer that contains the space for the non-complete message\n            self.stubBuffer = new Buffer(data.length)\n            // Copy the data to the stub buffer\n            data.copy(self.stubBuffer, 0);\n            // Exit parsing loop\n            data = new Buffer(0);\n          }\n        }\n      }\n    }\n  }\n}\n\n/**\n * Connect\n * @method\n */\nConnection.prototype.connect = function(_options) {\n  var self = this;\n  _options = _options || {};\n  // Check if we are overriding the promoteLongs\n  if(typeof _options.promoteLongs == 'boolean') {\n    self.responseOptions.promoteLongs = _options.promoteLongs;\n  }\n\n  // Create new connection instance\n  self.connection = self.domainSocket\n    ? net.createConnection(self.host)\n    : net.createConnection(self.port, self.host);\n\n  // Set the options for the connection\n  self.connection.setKeepAlive(self.keepAlive, self.keepAliveInitialDelay);\n  self.connection.setTimeout(self.connectionTimeout);\n  self.connection.setNoDelay(self.noDelay);\n\n  // If we have ssl enabled\n  if(self.ssl) {\n    var sslOptions = {\n        socket: self.connection\n      , rejectUnauthorized: self.rejectUnauthorized\n    }\n\n    if(self.ca) sslOptions.ca = self.ca;\n    if(self.cert) sslOptions.cert = self.cert;\n    if(self.key) sslOptions.key = self.key;\n    if(self.passphrase) sslOptions.passphrase = self.passphrase;\n\n    // Override checkServerIdentity behavior\n    if(self.checkServerIdentity == false) {\n      // Skip the identiy check by retuning undefined as per node documents\n      // https://nodejs.org/api/tls.html#tls_tls_connect_options_callback\n      sslOptions.checkServerIdentity = function(servername, cert) {\n        return undefined;\n      }\n    } else if(typeof self.checkServerIdentity == 'function') {\n      sslOptions.checkServerIdentity = self.checkServerIdentity;\n    }\n\n    try {\n      self.connection = tls.connect(self.port, self.host, sslOptions, function() {\n        // Error on auth or skip\n        if(self.connection.authorizationError && self.rejectUnauthorized) {\n          return self.emit(\"error\", self.connection.authorizationError, self, {ssl:true});\n        }\n\n        // Set socket timeout instead of connection timeout\n        self.connection.setTimeout(self.socketTimeout);\n        // We are done emit connect\n        self.emit('connect', self);\n      });\n    }\n    catch (error) {\n      // In the case of an invalid key, the Node tls module raises the error\n      // Error: error:0B080074:x509 certificate routines:X509_check_private_key\n      // but does not emit an error event like all other errors. We handle this\n      // and other potential inconsistencies here.\n      process.nextTick(function() {\n        return self.emit(\"error\", error, self, {ssl:true});\n      });\n    }\n    self.connection.setTimeout(self.connectionTimeout);\n  } else {\n    self.connection.on('connect', function() {\n      // Set socket timeout instead of connection timeout\n      self.connection.setTimeout(self.socketTimeout);\n      // Emit connect event\n      self.emit('connect', self);\n    });\n  }\n\n  // Add handlers for events\n  self.connection.once('error', errorHandler(self));\n  self.connection.once('timeout', timeoutHandler(self));\n  self.connection.once('close', closeHandler(self));\n  self.connection.on('data', dataHandler(self));\n}\n\n/**\n * Unref this connection\n * @method\n * @return {boolean}\n */\nConnection.prototype.unref = function() {\n  if (this.connection) this.connection.unref();\n  else {\n    var self = this;\n    this.once('connect', function() {\n      self.connection.unref();\n    });\n  }\n}\n\n/**\n * Destroy connection\n * @method\n */\nConnection.prototype.destroy = function() {\n  if(this.connection) {\n    if (this.connection.unref) {\n      this.connection.unref();\n    }\n    this.connection.end();\n    this.connection.destroy();\n  }\n\n  this.destroyed = true;\n}\n\n/**\n * Write to connection\n * @method\n * @param {Command} command Command to write out need to implement toBin and toBinUnified\n */\nConnection.prototype.write = function(buffer) {\n  // Debug Log\n  if(this.logger.isDebug()) {\n    if(!Array.isArray(buffer)) {\n      this.logger.debug(f('writing buffer [%s] to %s:%s', buffer.toString('hex'), this.host, this.port));\n    } else {\n      for(var i = 0; i < buffer.length; i++)\n        this.logger.debug(f('writing buffer [%s] to %s:%s', buffer[i].toString('hex'), this.host, this.port));\n    }\n  }\n\n  // Write out the command\n  if(!Array.isArray(buffer)) return this.connection.write(buffer, 'binary');\n  // Iterate over all buffers and write them in order to the socket\n  for(var i = 0; i < buffer.length; i++) this.connection.write(buffer[i], 'binary');\n}\n\n/**\n * Return id of connection as a string\n * @method\n * @return {string}\n */\nConnection.prototype.toString = function() {\n  return \"\" + this.id;\n}\n\n/**\n * Return json object of connection\n * @method\n * @return {object}\n */\nConnection.prototype.toJSON = function() {\n  return {id: this.id, host: this.host, port: this.port};\n}\n\n/**\n * Is the connection connected\n * @method\n * @return {boolean}\n */\nConnection.prototype.isConnected = function() {\n  if(this.destroyed) return false;\n  return !this.connection.destroyed && this.connection.writable;\n}\n\n/**\n * A server connect event, used to verify that the connection is up and running\n *\n * @event Connection#connect\n * @type {Connection}\n */\n\n/**\n * The server connection closed, all pool connections closed\n *\n * @event Connection#close\n * @type {Connection}\n */\n\n/**\n * The server connection caused an error, all pool connections closed\n *\n * @event Connection#error\n * @type {Connection}\n */\n\n/**\n * The server connection timed out, all pool connections closed\n *\n * @event Connection#timeout\n * @type {Connection}\n */\n\n/**\n * The driver experienced an invalid message, all pool connections closed\n *\n * @event Connection#parseError\n * @type {Connection}\n */\n\nmodule.exports = Connection;\n"]}