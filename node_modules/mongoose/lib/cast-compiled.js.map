{"version":3,"sources":["cast.js"],"names":[],"mappings":"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","file":"cast-compiled.js","sourcesContent":["/*!\n * Module dependencies.\n */\n\nvar utils = require('./utils');\nvar Types = require('./schema/index');\n\n/**\n * Handles internal casting for queries\n *\n * @param {Schema} schema\n * @param {Object} obj Object to cast\n * @api private\n */\nmodule.exports = function cast(schema, obj) {\n  var paths = Object.keys(obj),\n      i = paths.length,\n      any$conditionals,\n      schematype,\n      nested,\n      path,\n      type,\n      val;\n\n  while (i--) {\n    path = paths[i];\n    val = obj[path];\n\n    if (path === '$or' || path === '$nor' || path === '$and') {\n      var k = val.length;\n\n      while (k--) {\n        val[k] = cast(schema, val[k]);\n      }\n    } else if (path === '$where') {\n      type = typeof val;\n\n      if (type !== 'string' && type !== 'function') {\n        throw new Error('Must have a string or function for $where');\n      }\n\n      if (type === 'function') {\n        obj[path] = val.toString();\n      }\n\n      continue;\n    } else if (path === '$elemMatch') {\n      val = cast(schema, val);\n    } else {\n      if (!schema) {\n        // no casting for Mixed types\n        continue;\n      }\n\n      schematype = schema.path(path);\n\n      if (!schematype) {\n        // Handle potential embedded array queries\n        var split = path.split('.'),\n            j = split.length,\n            pathFirstHalf,\n            pathLastHalf,\n            remainingConds;\n\n        // Find the part of the var path that is a path of the Schema\n        while (j--) {\n          pathFirstHalf = split.slice(0, j).join('.');\n          schematype = schema.path(pathFirstHalf);\n          if (schematype) {\n            break;\n          }\n        }\n\n        // If a substring of the input path resolves to an actual real path...\n        if (schematype) {\n          // Apply the casting; similar code for $elemMatch in schema/array.js\n          if (schematype.caster && schematype.caster.schema) {\n            remainingConds = {};\n            pathLastHalf = split.slice(j).join('.');\n            remainingConds[pathLastHalf] = val;\n            obj[path] = cast(schematype.caster.schema, remainingConds)[pathLastHalf];\n          } else {\n            obj[path] = val;\n          }\n          continue;\n        }\n\n        if (utils.isObject(val)) {\n          // handle geo schemas that use object notation\n          // { loc: { long: Number, lat: Number }\n\n          var geo = val.$near ? '$near' :\n                    val.$nearSphere ? '$nearSphere' :\n                    val.$within ? '$within' :\n                    val.$geoIntersects ? '$geoIntersects' : '';\n\n          if (!geo) {\n            continue;\n          }\n\n          var numbertype = new Types.Number('__QueryCasting__');\n          var value = val[geo];\n\n          if (val.$maxDistance) {\n            val.$maxDistance = numbertype.castForQuery(val.$maxDistance);\n          }\n\n          if (geo === '$within') {\n            var withinType = value.$center\n                || value.$centerSphere\n                || value.$box\n                || value.$polygon;\n\n            if (!withinType) {\n              throw new Error('Bad $within paramater: ' + JSON.stringify(val));\n            }\n\n            value = withinType;\n          } else if (geo === '$near' &&\n              typeof value.type === 'string' && Array.isArray(value.coordinates)) {\n            // geojson; cast the coordinates\n            value = value.coordinates;\n          } else if ((geo === '$near' || geo === '$nearSphere' || geo === '$geoIntersects') &&\n              value.$geometry && typeof value.$geometry.type === 'string' &&\n              Array.isArray(value.$geometry.coordinates)) {\n            // geojson; cast the coordinates\n            value = value.$geometry.coordinates;\n          }\n\n          _cast(value, numbertype);\n        }\n      } else if (val === null || val === undefined) {\n        obj[path] = null;\n        continue;\n      } else if (val.constructor.name === 'Object') {\n        any$conditionals = Object.keys(val).some(function(k) {\n          return k.charAt(0) === '$' && k !== '$id' && k !== '$ref';\n        });\n\n        if (!any$conditionals) {\n          obj[path] = schematype.castForQuery(val);\n        } else {\n          var ks = Object.keys(val),\n              $cond;\n\n          k = ks.length;\n\n          while (k--) {\n            $cond = ks[k];\n            nested = val[$cond];\n\n            if ($cond === '$exists') {\n              if (typeof nested !== 'boolean') {\n                throw new Error('$exists parameter must be Boolean');\n              }\n              continue;\n            }\n\n            if ($cond === '$type') {\n              if (typeof nested !== 'number') {\n                throw new Error('$type parameter must be Number');\n              }\n              continue;\n            }\n\n            if ($cond === '$not') {\n              cast(schema, nested);\n            } else {\n              val[$cond] = schematype.castForQuery($cond, nested);\n            }\n          }\n        }\n      } else {\n        obj[path] = schematype.castForQuery(val);\n      }\n    }\n  }\n\n  return obj;\n};\n\nfunction _cast(val, numbertype) {\n  if (Array.isArray(val)) {\n    val.forEach(function(item, i) {\n      if (Array.isArray(item) || utils.isObject(item)) {\n        return _cast(item, numbertype);\n      }\n      val[i] = numbertype.castForQuery(item);\n    });\n  } else {\n    var nearKeys = Object.keys(val);\n    var nearLen = nearKeys.length;\n    while (nearLen--) {\n      var nkey = nearKeys[nearLen];\n      var item = val[nkey];\n      if (Array.isArray(item) || utils.isObject(item)) {\n        _cast(item, numbertype);\n        val[nkey] = item;\n      } else {\n        val[nkey] = numbertype.castForQuery(item);\n      }\n    }\n  }\n}\n"]}